import { NgZone } from '@angular/core';
import { BehaviorSubject, Observable } from 'rxjs';
import { Attachment, Channel, ChannelFilters, ChannelOptions, ChannelResponse, ChannelSort, Event, FormatMessageResponse, MessageResponse, ReactionResponse, UserResponse } from 'stream-chat';
import { ChatClientService, ClientEvent } from './chat-client.service';
import { NotificationService } from './notification.service';
import { AttachmentUpload, ChannelQueryResult, ChannelQueryState, ChannelQueryType, DefaultStreamChatGenerics, MessageInput, MessageReactionType, NextPageConfiguration, StreamMessage } from './types';
import * as i0 from "@angular/core";
/**
 * The `ChannelService` provides data and interaction for the channel list and message list.
 */
export declare class ChannelService<T extends DefaultStreamChatGenerics = DefaultStreamChatGenerics> {
    private chatClientService;
    private ngZone;
    private notificationService;
    /**
     * Emits `false` if there are no more pages of channels that can be loaded.
     */
    hasMoreChannels$: Observable<boolean>;
    /**
     * Emits the currently loaded and [watched](/chat/docs/javascript/watch_channel/) channel list.
     *
     * :::important
     * If you want to subscribe to channel events, you need to manually reenter Angular's change detection zone, our [Change detection guide](/chat/docs/sdk/angular/concepts/change-detection/) explains this in detail.
     * :::
     */
    channels$: Observable<Channel<T>[] | undefined>;
    /**
     * The result of the latest channel query request.
     */
    channelQueryState$: Observable<ChannelQueryState | undefined>;
    /**
     * Emits the currently active channel.
     *
     * :::important
     * If you want to subscribe to channel events, you need to manually reenter Angular's change detection zone, our [Change detection guide](/chat/docs/sdk/angular/concepts/change-detection/) explains this in detail.
     * :::
     *
     * The active channel will always be marked as read when a new message is received
     */
    activeChannel$: Observable<Channel<T> | undefined>;
    /**
     * Emits the list of currently loaded messages of the active channel.
     */
    activeChannelMessages$: Observable<StreamMessage<T>[]>;
    /**
     * Emits the list of pinned messages of the active channel.
     */
    activeChannelPinnedMessages$: Observable<StreamMessage<T>[]>;
    /**
     * Emits the id of the currently selected parent message. If no message is selected, it emits undefined.
     */
    activeParentMessageId$: Observable<string | undefined>;
    /**
     * Emits the list of currently loaded thread replies belonging to the selected parent message. If there is no currently active thread it emits an empty array.
     */
    activeThreadMessages$: Observable<StreamMessage<T>[]>;
    /**
     * Emits the currently selected parent message. If no message is selected, it emits undefined.
     */
    activeParentMessage$: Observable<StreamMessage<T> | undefined>;
    /**
     * Emits the currently selected message to quote
     */
    messageToQuote$: Observable<StreamMessage<T> | undefined>;
    /**
     * Emits the ID of the message the message list should jump to (can be a channel message or thread message)
     */
    jumpToMessage$: Observable<{
        id?: string;
        parentId?: string;
    }>;
    /**
     * Emits the list of users that are currently typing in the channel (current user is not included)
     */
    usersTypingInChannel$: Observable<UserResponse<T>[]>;
    /**
     * Emits the list of users that are currently typing in the active thread (current user is not included)
     */
    usersTypingInThread$: Observable<UserResponse<T>[]>;
    /**
     * Emits a map that contains the date of the latest message sent by the current user by channels (this is used to detect if slow mode countdown should be started)
     */
    latestMessageDateByUserByChannels$: Observable<{
        [key: string]: Date;
    }>;
    /**
     * If you're using [semantic filters for moderation](/moderation/docs/) you can set up rules for bouncing messages.
     *
     * If a message is bounced, it will be emitted via this `Observable`. The built-in [`MessageBouncePrompt` component](/chat/docs/sdk/angular/components/MessageBouncePromptComponent/) will display the bounce option to the user if a bounced message is clicked.
     */
    bouncedMessage$: BehaviorSubject<StreamMessage<T> | undefined>;
    /**
     * The last read message id of the active channel, it's used by the message list component to display unread UI, and jump to latest read message
     *
     * This property isn't always updated, please use `channel.read` to display up-to-date read information
     */
    activeChannelLastReadMessageId?: string;
    /**
     * The unread count of the active channel, it's used by the message list component to display unread UI
     *
     * This property isn't always updated, please use `channel.read` to display up-to-date read information
     */
    activeChannelUnreadCount?: number;
    /**
     * Custom event handler to call if a new message received from a channel that is not being watched, provide an event handler if you want to override the [default channel list ordering](/chat/docs/sdk/angular/services/ChannelService/#channels/)
     *
     * If you're adding a new channel, make sure that it's a [watched](/chat/docs/javascript/watch_channel/) channel.
     */
    customNewMessageNotificationHandler?: (clientEvent: ClientEvent, channelListSetter: (channels: Channel<T>[], shouldStopWatchingRemovedChannels?: boolean) => void) => void;
    /**
     * Custom event handler to call when the user is added to a channel, provide an event handler if you want to override the [default channel list ordering](/chat/docs/sdk/angular/services/ChannelService/#channels/).
     *
     * If you're adding a new channel, make sure that it's a [watched](/chat/docs/javascript/watch_channel/) channel.
     */
    customAddedToChannelNotificationHandler?: (clientEvent: ClientEvent, channelListSetter: (channels: Channel<T>[], shouldStopWatchingRemovedChannels?: boolean) => void) => void;
    /**
     * Custom event handler to call when the user is removed from a channel, provide an event handler if you want to override the [default channel list ordering](/chat/docs/sdk/angular/services/ChannelService/#channels/).
     *
     * If you're adding a new channel, make sure that it's a [watched](/chat/docs/javascript/watch_channel/) channel.
     */
    customRemovedFromChannelNotificationHandler?: (clientEvent: ClientEvent, channelListSetter: (channels: Channel<T>[], shouldStopWatchingRemovedChannels?: boolean) => void) => void;
    /**
     * Custom event handler to call when a channel is deleted, provide an event handler if you want to override the [default channel list ordering](/chat/docs/sdk/angular/services/ChannelService/#channels/).
     *
     * If you're adding a new channel, make sure that it's a [watched](/chat/docs/javascript/watch_channel/) channel.
     */
    customChannelDeletedHandler?: (event: Event, channel: Channel<T>, channelListSetter: (channels: Channel<T>[], shouldStopWatchingRemovedChannels?: boolean) => void, messageListSetter: (messages: StreamMessage<T>[]) => void, threadListSetter: (messages: StreamMessage<T>[]) => void, parentMessageSetter: (message: StreamMessage<T> | undefined) => void) => void;
    /**
     * Custom event handler to call when a channel is updated, provide an event handler if you want to override the [default channel list ordering](/chat/docs/sdk/angular/services/ChannelService/#channels/).
     *
     * If you're adding a new channel, make sure that it's a [watched](/chat/docs/javascript/watch_channel/) channel.
     */
    customChannelUpdatedHandler?: (event: Event, channel: Channel<T>, channelListSetter: (channels: Channel<T>[], shouldStopWatchingRemovedChannels?: boolean) => void, messageListSetter: (messages: StreamMessage[]) => void, threadListSetter: (messages: StreamMessage[]) => void, parentMessageSetter: (message: StreamMessage | undefined) => void) => void;
    /**
     * Custom event handler to call when a channel is truncated, provide an event handler if you want to override the [default channel list ordering](/chat/docs/sdk/angular/services/ChannelService/#channels/).
     *
     * If you're adding a new channel, make sure that it's a [watched](/chat/docs/javascript/watch_channel/) channel.
     */
    customChannelTruncatedHandler?: (event: Event, channel: Channel<T>, channelListSetter: (channels: Channel<T>[], shouldStopWatchingRemovedChannels?: boolean) => void, messageListSetter: (messages: StreamMessage<T>[]) => void, threadListSetter: (messages: StreamMessage<T>[]) => void, parentMessageSetter: (message: StreamMessage<T> | undefined) => void) => void;
    /**
     * Custom event handler to call when a channel becomes hidden, provide an event handler if you want to override the [default channel list ordering](/chat/docs/sdk/angular/services/ChannelService/#channels/).
     *
     * If you're adding a new channel, make sure that it's a [watched](/chat/docs/javascript/watch_channel/) channel.
     */
    customChannelHiddenHandler?: (event: Event, channel: Channel<T>, channelListSetter: (channels: Channel<T>[], shouldStopWatchingRemovedChannels?: boolean) => void, messageListSetter: (messages: StreamMessage<T>[]) => void, threadListSetter: (messages: StreamMessage<T>[]) => void, parentMessageSetter: (message: StreamMessage<T> | undefined) => void) => void;
    /**
     * Custom event handler to call when a channel becomes visible, provide an event handler if you want to override the [default channel list ordering](/chat/docs/sdk/angular/services/ChannelService/#channels/).
     *
     * If you're adding a new channel, make sure that it's a [watched](/chat/docs/javascript/watch_channel/) channel.
     */
    customChannelVisibleHandler?: (event: Event, channel: Channel<T>, channelListSetter: (channels: Channel<T>[], shouldStopWatchingRemovedChannels?: boolean) => void, messageListSetter: (messages: StreamMessage<T>[]) => void, threadListSetter: (messages: StreamMessage<T>[]) => void, parentMessageSetter: (message: StreamMessage<T> | undefined) => void) => void;
    /**
     * Custom event handler to call if a new message received from a channel that is being watched, provide an event handler if you want to override the [default channel list ordering](/chat/docs/sdk/angular/services/ChannelService/#channels/).
     *
     * If you're adding a new channel, make sure that it's a [watched](/chat/docs/javascript/watch_channel/) channel.
     */
    customNewMessageHandler?: (event: Event, channel: Channel<T>, channelListSetter: (channels: Channel<T>[], shouldStopWatchingRemovedChannels?: boolean) => void, messageListSetter: (messages: StreamMessage<T>[]) => void, threadListSetter: (messages: StreamMessage<T>[]) => void, parentMessageSetter: (message: StreamMessage<T> | undefined) => void) => void;
    /**
     * You can override the default file upload request - you can use this to upload files to your own CDN
     */
    customFileUploadRequest?: (file: File, channel: Channel<T>) => Promise<{
        file: string;
    }>;
    /**
     * You can override the default image upload request - you can use this to upload images to your own CDN
     */
    customImageUploadRequest?: (file: File, channel: Channel<T>) => Promise<{
        file: string;
    }>;
    /**
     * You can override the default file delete request - override this if you use your own CDN
     */
    customFileDeleteRequest?: (url: string, channel: Channel<T>) => Promise<void>;
    /**
     * You can override the default image delete request - override this if you use your own CDN
     */
    customImageDeleteRequest?: (url: string, channel: Channel<T>) => Promise<void>;
    /**
     * The provided method will be called before deleting a message. If the returned Promise resolves to `true` to deletion will go ahead. If `false` is returned, the message won't be deleted.
     */
    messageDeleteConfirmationHandler?: (message: StreamMessage<T>) => Promise<boolean>;
    /**
     * The provided method will be called before a new message is sent to Stream's API. You can use this hook to tranfrom or enrich the message being sent.
     */
    beforeSendMessage?: (input: MessageInput<T>) => MessageInput<T> | Promise<MessageInput<T>>;
    /**
     * The provided method will be called before a message is sent to Stream's API for update. You can use this hook to tranfrom or enrich the message being updated.
     */
    beforeUpdateMessage?: (message: StreamMessage<T>) => StreamMessage<T> | Promise<StreamMessage<T>>;
    /**
     * @internal
     */
    static readonly MAX_MESSAGE_REACTIONS_TO_FETCH = 1200;
    /**
     * @internal
     */
    isMessageLoadingInProgress: boolean;
    messagePageSize: number;
    private channelsSubject;
    private activeChannelSubject;
    private activeChannelMessagesSubject;
    private activeChannelPinnedMessagesSubject;
    private hasMoreChannelsSubject;
    private activeChannelSubscriptions;
    private channelSubscriptions;
    private activeParentMessageIdSubject;
    private activeThreadMessagesSubject;
    private jumpToMessageSubject;
    private latestMessageDateByUserByChannelsSubject;
    private readonly attachmentMaxSizeFallbackInMB;
    private messageToQuoteSubject;
    private usersTypingInChannelSubject;
    private usersTypingInThreadSubject;
    private _shouldMarkActiveChannelAsRead;
    private shouldSetActiveChannel;
    private clientEventsSubscription;
    private isStateRecoveryInProgress;
    private channelQueryStateSubject;
    private channelQuery?;
    private _customPaginator;
    private channelListSetter;
    private messageListSetter;
    private threadListSetter;
    private parentMessageSetter;
    private dismissErrorNotification?;
    private areReadEventsPaused;
    private markReadThrottleTime;
    private markReadTimeout?;
    private scheduledMarkReadRequest?;
    constructor(chatClientService: ChatClientService<T>, ngZone: NgZone, notificationService: NotificationService);
    /**
     * If set to false, read events won't be sent as new messages are received. If set to true active channel (if any) will immediately be marked as read.
     */
    get shouldMarkActiveChannelAsRead(): boolean;
    /**
     * If set to false, read events won't be sent as new messages are received. If set to true active channel (if any) will immediately be marked as read.
     */
    set shouldMarkActiveChannelAsRead(shouldMarkActiveChannelAsRead: boolean);
    /**
     * By default the SDK uses an offset based pagination, you can change/extend this by providing your own custom paginator method.
     *
     * The method will be called with the result of the latest channel query.
     *
     * You can return either an offset, or a filter using the [`$lte`/`$gte` operator](/chat/docs/javascript/query_syntax_operators/). If you return a filter, it will be merged with the filter provided for the `init` method.
     */
    set customPaginator(paginator: ((channelQueryResult: Channel<T>[]) => NextPageConfiguration) | undefined);
    /**
     * Sets the given `channel` as active and marks it as read.
     * If the channel wasn't previously part of the channel, it will be added to the beginning of the list.
     * @param channel
     */
    setAsActiveChannel(channel: Channel<T>): void;
    /**
     * Deselects the currently active (if any) channel
     */
    deselectActiveChannel(): void;
    /**
     * Sets the given `message` as an active parent message. If `undefined` is provided, it will deleselect the current parent message.
     * @param message
     * @param loadMessagesForm
     */
    setAsActiveParentMessage(message: StreamMessage<T> | undefined, loadMessagesForm?: 'request' | 'state'): Promise<void>;
    /**
     * Loads the next page of messages of the active channel. The page size can be set in the [query option](/chat/docs/javascript/query_channels/#query-options) object.
     * @param direction
     */
    loadMoreMessages(direction?: 'older' | 'newer'): false | Promise<import("stream-chat").QueryChannelAPIResponse<T>> | undefined;
    /**
     * Loads the next page of messages of the active thread. The page size can be set in the [query option](/chat/docs/javascript/query_channels/#query-options) object.
     * @param direction
     */
    loadMoreThreadReplies(direction?: 'older' | 'newer'): false | Promise<void>;
    /**
     * Queries the channels with the given filters, sorts and options. More info about [channel querying](/chat/docs/javascript/query_channels/) can be found in the platform documentation. By default the first channel in the list will be set as active channel and will be marked as read.
     * @param filters
     * @param sort
     * @param options
     * @param shouldSetActiveChannel Decides if the first channel in the result should be made as an active channel or not.
     * @returns the list of channels found by the query
     */
    init(filters: ChannelFilters<T>, sort?: ChannelSort<T>, options?: ChannelOptions, shouldSetActiveChannel?: boolean): Promise<Channel<T>[]>;
    /**
     * Queries the channels with the given query function. More info about [channel querying](/chat/docs/javascript/query_channels/) can be found in the platform documentation.
     * @param query
     * @param options
     * @param options.shouldSetActiveChannel The `shouldSetActiveChannel` specifies if the first channel in the result should be selected as the active channel or not. Default is `true`.
     * @param options.messagePageSize How many messages should we load? The default is 25
     * @returns the channels that were loaded
     */
    initWithCustomQuery(query: (queryType: ChannelQueryType) => Promise<ChannelQueryResult<T>>, options?: {
        shouldSetActiveChannel: boolean;
        messagePageSize: number;
    }): Promise<Channel<T>[]>;
    /**
     * Resets the `activeChannel$`, `channels$` and `activeChannelMessages$` Observables. Useful when disconnecting a chat user, use in combination with [`disconnectUser`](/chat/docs/sdk/angular/services/ChatClientService/#disconnectuser/).
     */
    reset(): void;
    /**
     * Loads the next page of channels. The page size can be set in the [query option](/chat/docs/javascript/query_channels/#query-options) object.
     */
    loadMoreChannels(): Promise<void>;
    /**
     * Adds a reaction to a message.
     * @param messageId The id of the message to add the reaction to
     * @param reactionType The type of the reaction
     * @param customData
     */
    addReaction(messageId: string, reactionType: MessageReactionType, customData?: T['reactionType']): Promise<void>;
    /**
     * Removes a reaction from a message.
     * @param messageId The id of the message to remove the reaction from
     * @param reactionType Thr type of reaction to remove
     */
    removeReaction(messageId: string, reactionType: MessageReactionType): Promise<void>;
    /**
     * Sends a message to the active channel. The message is immediately added to the message list, if an error occurs and the message can't be sent, the error is indicated in `state` of the message.
     * @param text The text of the message
     * @param attachments The attachments
     * @param mentionedUsers Mentioned users
     * @param parentId Id of the parent message (if sending a thread reply)
     * @param quotedMessageId Id of the message to quote (if sending a quote reply)
     * @param customData
     */
    sendMessage(text: string, attachments?: Attachment<T>[], mentionedUsers?: UserResponse<T>[], parentId?: string | undefined, quotedMessageId?: string | undefined, customData?: undefined | Partial<T['messageType']>): Promise<StreamMessage<T>>;
    /**
     * Resends the given message to the active channel
     * @param message The message to resend
     */
    resendMessage(message: StreamMessage): Promise<StreamMessage<T>>;
    /**
     * Updates the message in the active channel
     * @param message Mesage to be updated
     */
    updateMessage(message: StreamMessage<T>): Promise<StreamMessage<T> | (T["messageType"] & {
        id: string;
        attachments?: Attachment<T>[] | undefined;
        html?: string | undefined;
        mml?: string | undefined;
        parent_id?: string | undefined;
        pin_expires?: string | null | undefined;
        pinned?: boolean | undefined;
        pinned_at?: string | null | undefined;
        poll_id?: string | undefined;
        quoted_message_id?: string | undefined;
        show_in_channel?: boolean | undefined;
        silent?: boolean | undefined;
        text?: string | undefined;
        user?: UserResponse<T> | null | undefined;
        user_id?: string | undefined;
    } & {
        type: import("stream-chat").MessageLabel;
        args?: string | undefined;
        before_message_send_failed?: boolean | undefined;
        channel?: ChannelResponse<T> | undefined;
        cid?: string | undefined;
        command?: string | undefined;
        command_info?: {
            name?: string | undefined;
        } | undefined;
        created_at?: string | undefined;
        deleted_at?: string | undefined;
        deleted_reply_count?: number | undefined;
        i18n?: (import("stream-chat").RequireAtLeastOne<Record<"_text" | "id_text" | "hr_text" | "th_text" | "tr_text" | "so_text" | "no_text" | "af_text" | "am_text" | "ar_text" | "az_text" | "bg_text" | "bn_text" | "bs_text" | "cs_text" | "da_text" | "de_text" | "el_text" | "en_text" | "es_text" | "es-MX_text" | "et_text" | "fa_text" | "fa-AF_text" | "fi_text" | "fr_text" | "fr-CA_text" | "ha_text" | "he_text" | "hi_text" | "hu_text" | "it_text" | "ja_text" | "ka_text" | "ko_text" | "lt_text" | "lv_text" | "ms_text" | "nl_text" | "pl_text" | "ps_text" | "pt_text" | "ro_text" | "ru_text" | "sk_text" | "sl_text" | "sq_text" | "sr_text" | "sv_text" | "sw_text" | "ta_text" | "tl_text" | "uk_text" | "ur_text" | "vi_text" | "zh_text" | "zh-TW_text", string>> & {
            language: import("stream-chat").TranslationLanguages;
        }) | undefined;
        latest_reactions?: ReactionResponse<T>[] | undefined;
        mentioned_users?: UserResponse<T>[] | undefined;
        message_text_updated_at?: string | undefined;
        moderation_details?: import("stream-chat").ModerationDetailsResponse | undefined;
        own_reactions?: ReactionResponse<T>[] | null | undefined;
        pin_expires?: string | null | undefined;
        pinned_at?: string | null | undefined;
        pinned_by?: UserResponse<T> | null | undefined;
        poll?: import("stream-chat").PollResponse<T> | undefined;
        reaction_counts?: {
            [key: string]: number;
        } | null | undefined;
        reaction_groups?: {
            [key: string]: import("stream-chat").ReactionGroupResponse;
        } | null | undefined;
        reaction_scores?: {
            [key: string]: number;
        } | null | undefined;
        reply_count?: number | undefined;
        shadowed?: boolean | undefined;
        status?: string | undefined;
        thread_participants?: UserResponse<T>[] | undefined;
        updated_at?: string | undefined;
    } & {
        quoted_message?: import("stream-chat").MessageResponseBase<T> | undefined;
    } & Omit<MessageResponse<{
        attachmentType: import("stream-chat").UR;
        channelType: import("stream-chat").UR;
        commandType: import("stream-chat").LiteralStringForUnion;
        eventType: import("stream-chat").UR;
        memberType: import("stream-chat").UR;
        messageType: {};
        pollOptionType: import("stream-chat").UR;
        pollType: import("stream-chat").UR;
        reactionType: import("stream-chat").UR;
        userType: import("stream-chat").UR;
    }>, "status" | "created_at" | "pinned_at" | "updated_at" | "deleted_at"> & import("stream-chat").UR & {
        created_at: Date;
        deleted_at: Date | null;
        pinned_at: Date | null;
        status: string;
        updated_at: Date;
    })>;
    /**
     * Deletes the message from the active channel
     * @param message Message to be deleted
     * @param isLocalDelete set this `true` if you want to delete a message that's only part of the local state, not yet saved on the backend
     */
    deleteMessage(message: StreamMessage, isLocalDelete?: boolean): Promise<void>;
    /**
     * Uploads files to the channel. If you want to know more about [file uploads](/chat/docs/javascript/file_uploads/) check out the platform documentation.
     * @param uploads the attachments to upload (output of the [`AttachmentService`](/chat/docs/sdk/angular/services/AttachmentService/))
     * @returns the result of file upload requests
     */
    uploadAttachments(uploads: AttachmentUpload[]): Promise<AttachmentUpload[]>;
    /**
     * Deletes an uploaded file by URL. If you want to know more about [file uploads](/chat/docs/javascript/file_uploads/) check out the platform documentation
     * @param attachmentUpload Attachment to be deleted (output of the [`AttachmentService`](/chat/docs/sdk/angular/services/AttachmentService/))
     */
    deleteAttachment(attachmentUpload: AttachmentUpload): Promise<void>;
    /**
     * Returns the autocomplete options for current channel members. If the channel has less than 100 members, it returns the channel members, otherwise sends a [search request](/chat/docs/javascript/query_members/#pagination-and-ordering) with the given search term.
     * @param searchTerm Text to search for in the names of members
     * @returns The list of members matching the search filter
     */
    autocompleteMembers(searchTerm: string): Promise<import("stream-chat").ChannelMemberResponse<T>[]>;
    /**
     * [Runs a message action](https://getstream.io/chat/docs/rest/#messages-runmessageaction) in the current channel. Updates the message list based on the action result (if no message is returned, the message will be removed from the message list).
     * @param messageId
     * @param formData
     * @param parentMessageId
     */
    sendAction(messageId: string, formData: Record<string, string>, parentMessageId?: string): Promise<void>;
    /**
     * Selects or deselects the current message to quote reply to
     * @param message The message to select, if called with `undefined`, it deselects the message
     */
    selectMessageToQuote(message: StreamMessage | undefined): void;
    /**
     * Add a new channel to the channel list
     * The channel will be added to the beginning of the channel list
     * @param channel
     */
    addChannel(channel: Channel<T>): void;
    /**
     *
     * @param cid
     * @param shouldStopWatching
     */
    removeChannel(cid: string, shouldStopWatching?: boolean): void;
    private sendMessageRequest;
    /**
     * Jumps to the selected message inside the message list, if the message is not yet loaded, it'll load the message (and it's surroundings) from the API.
     * @param messageId The ID of the message to be loaded, 'latest' means jump to the latest messages
     * @param parentMessageId The ID of the parent message if we want to load a thread message
     */
    jumpToMessage(messageId: string, parentMessageId?: string): Promise<void>;
    /**
     * Clears the currently selected message to jump
     */
    clearMessageJump(): void;
    /**
     * Pins the given message in the channel
     * @param message
     */
    pinMessage(message: StreamMessage<DefaultStreamChatGenerics>): Promise<void>;
    /**
     * Removes the given message from pinned messages
     * @param message
     */
    unpinMessage(message: StreamMessage<DefaultStreamChatGenerics>): Promise<void>;
    private handleNotification;
    private handleRemovedFromChannelNotification;
    private handleNewMessageNotification;
    private handleAddedToChannelNotification;
    private addChannelFromNotification;
    private watchForActiveChannelEvents;
    /**
     * Call this method if user started typing in the active channel
     * @param parentId The id of the parent message, if user is typing in a thread
     */
    typingStarted(parentId?: string): Promise<void>;
    /**
     * Call this method if user stopped typing in the active channel
     * @param parentId The id of the parent message, if user were typing in a thread
     */
    typingStopped(parentId?: string): Promise<void>;
    /**
     * The current list of channels
     */
    get channels(): Channel<T>[];
    /**
     * The current active channel
     */
    get activeChannel(): Channel<T> | undefined;
    /**
     * The current active channel messages
     */
    get activeChannelMessages(): (StreamMessage<T> | MessageResponse<T> | FormatMessageResponse<T>)[];
    /**
     * The current thread replies
     */
    get activeChannelThreadReplies(): (StreamMessage<T> | MessageResponse<T> | FormatMessageResponse<T>)[];
    /**
     * Get the last 1200 reactions of a message in the current active channel. If you need to fetch more reactions please use the [following endpoint](/chat/docs/javascript/send_reaction/#paginating-reactions).
     * @deprecated use [`messageReactionsService.queryReactions()`](/chat/docs/sdk/angular/services/MessageReactionsService/#queryreactions) instead
     * @param messageId
     * @returns all reactions of a message
     */
    getMessageReactions(messageId: string): Promise<ReactionResponse<T>[]>;
    /**
     * Marks the channel from the given message as unread
     * @param messageId
     * @returns the result of the request
     */
    markMessageUnread(messageId: string): Promise<import("stream-chat").APIResponse | null | undefined>;
    private messageUpdated;
    private messageReactionEventReceived;
    private formatMessage;
    private isStreamMessage;
    private isFormatMessageResponse;
    private stopWatchForActiveChannelEvents;
    private queryChannels;
    private watchForChannelEvents;
    private handleNewMessage;
    private handleChannelHidden;
    private handleChannelDeleted;
    private handleChannelVisible;
    private handleChannelUpdate;
    private handleChannelTruncate;
    private get canSendReadEvents();
    private transformToStreamMessage;
    private handleTypingStartEvent;
    private handleTypingStopEvent;
    private updateLatestMessages;
    private setChannelState;
    private markRead;
    private markReadThrottled;
    private flushMarkReadQueue;
    private _init;
    static ɵfac: i0.ɵɵFactoryDeclaration<ChannelService<any>, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<ChannelService<any>>;
}
