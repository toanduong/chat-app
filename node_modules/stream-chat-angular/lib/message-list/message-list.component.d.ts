import { AfterViewChecked, AfterViewInit, ChangeDetectorRef, NgZone, OnChanges, OnDestroy, OnInit, SimpleChanges, TemplateRef } from '@angular/core';
import { ChannelService } from '../channel.service';
import { Observable, Subject } from 'rxjs';
import { MessageContext, StreamMessage, TypingIndicatorContext, DateSeparatorContext, UnreadMessagesNotificationContext, UnreadMessagesIndicatorContext } from '../types';
import { ChatClientService } from '../chat-client.service';
import { GroupStyle } from './group-styles';
import { UserResponse } from 'stream-chat';
import { CustomTemplatesService } from '../custom-templates.service';
import { DateParserService } from '../date-parser.service';
import * as i0 from "@angular/core";
/**
 * The `MessageList` component renders a scrollable list of messages.
 */
export declare class MessageListComponent implements AfterViewChecked, OnChanges, OnInit, OnDestroy, AfterViewInit {
    private channelService;
    private chatClientService;
    private customTemplatesService;
    private dateParser;
    private ngZone;
    private cdRef;
    /**
     * Determines if the message list should display channel messages or [thread messages](/chat/docs/javascript/threads/).
     */
    mode: 'main' | 'thread';
    /**
     * The direction of the messages in the list, `bottom-to-top` means newest message is at the bottom of the message list and users scroll upwards to load older messages
     */
    direction: 'bottom-to-top' | 'top-to-bottom';
    /**
     * You can hide the "jump to latest" button while scrolling. A potential use-case for this input would be to [workaround a known issue on iOS Safar webview](https://github.com/GetStream/stream-chat-angular/issues/418)
     *
     */
    hideJumpToLatestButtonDuringScroll: boolean;
    /**
     * If `true` date separators will be displayed
     */
    displayDateSeparator: boolean;
    /**
     * If `true` unread indicator will be displayed
     */
    displayUnreadSeparator: boolean;
    /**
     * If date separators are displayed, you can set the horizontal position of the date text.
     */
    dateSeparatorTextPos: 'center' | 'right' | 'left';
    /**
     * `last-message` option will open the message list at the last message, `last-read-message` will open the list at the last unread message. This option only works if mode is `main`.
     */
    openMessageListAt: 'last-message' | 'last-read-message';
    /**
     * If the user has unread messages when they open the channel the UI shows the unread indicator / notification which features the unread count by default. This count will be increased every time a user receives a new message. If you don't want to show the unread count, you can turn that off.
     *
     * This is only applicable for `main` mode, as threads doesn't have read infromation.
     */
    hideUnreadCountForNotificationAndIndicator: boolean;
    /**
     * You can turn on and off the loading indicator that signals to users that more messages are being loaded to the message list
     */
    displayLoadingIndicator: boolean;
    typingIndicatorTemplate: TemplateRef<TypingIndicatorContext> | undefined;
    messageTemplate: TemplateRef<MessageContext> | undefined;
    customDateSeparatorTemplate: TemplateRef<DateSeparatorContext> | undefined;
    customnewMessagesIndicatorTemplate: TemplateRef<UnreadMessagesIndicatorContext> | undefined;
    customnewMessagesNotificationTemplate: TemplateRef<UnreadMessagesNotificationContext> | undefined;
    emptyMainMessageListTemplate: TemplateRef<void> | null;
    emptyThreadMessageListTemplate: TemplateRef<void> | null;
    messages$: Observable<StreamMessage[]>;
    enabledMessageActions: string[];
    isEmpty: boolean;
    newMessageCountWhileBeingScrolled: number;
    isUserScrolled: boolean | undefined;
    groupStyles: GroupStyle[];
    isNextMessageOnSeparateDate: boolean[];
    lastSentMessageId: string | undefined;
    parentMessage: StreamMessage | undefined;
    highlightedMessageId: string | undefined;
    loadingState: 'idle' | 'loading-top' | 'loading-bottom';
    scrollEndTimeout?: ReturnType<typeof setTimeout>;
    lastReadMessageId?: string;
    isUnreadNotificationVisible: boolean;
    firstUnreadMessageId?: string;
    unreadCount?: number;
    isJumpingToLatestUnreadMessage: boolean;
    isJumpToLatestButtonVisible: boolean;
    isJumpingToMessage: boolean;
    scroll$: Subject<void>;
    private scrollContainer;
    private parentMessageElement;
    private isNewMessageSentByUser;
    private subscriptions;
    private newMessageSubscription;
    private usersTypingInChannel$;
    private usersTypingInThread$;
    private isLatestMessageInList;
    private channelId?;
    private parsedDates;
    private isViewInited;
    private checkIfUnreadNotificationIsVisibleTimeout?;
    private jumpToMessageTimeouts;
    private jumpToLatestButtonVisibilityTimeout?;
    private forceRepaintSubject;
    private messageIdToAnchorTo?;
    private anchorMessageTopOffset?;
    private isSafari;
    private get class();
    private virtualizedList?;
    private scrollPosition$;
    private jumpToItemSubscription?;
    private queryStateSubscription?;
    constructor(channelService: ChannelService, chatClientService: ChatClientService, customTemplatesService: CustomTemplatesService, dateParser: DateParserService, ngZone: NgZone, cdRef: ChangeDetectorRef);
    messageNotificationJumpClicked: () => void;
    messageNotificationDismissClicked: () => void;
    ngOnInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    ngAfterViewInit(): void;
    ngAfterViewChecked(): void;
    ngOnDestroy(): void;
    trackByMessageId(_: number, item: StreamMessage): string;
    trackByUserId(_: number, user: UserResponse): string;
    jumpToLatestMessage(): void;
    scrollToBottom(): void;
    scrollToTop(): void;
    scrolled(): void;
    jumpToFirstUnreadMessage(): void;
    getTypingIndicatorContext(): TypingIndicatorContext;
    getTypingIndicatorText(users: UserResponse[]): string;
    isSentByCurrentUser(message?: StreamMessage): boolean;
    parseDate(date: Date): string | undefined;
    get replyCountParam(): {
        replyCount: number | undefined;
    };
    get emptyListTemplate(): TemplateRef<void> | null;
    private checkIfUserScrolled;
    private preserveScrollbarPosition;
    private forceRepaint;
    private getScrollPosition;
    private setMessages$;
    private resetScrollState;
    private disposeVirtualizedList;
    private get usersTyping$();
    private scrollMessageIntoView;
    private newMessageReceived;
    private checkIfOnSeparateDates;
    static ɵfac: i0.ɵɵFactoryDeclaration<MessageListComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<MessageListComponent, "stream-message-list", never, { "mode": "mode"; "direction": "direction"; "hideJumpToLatestButtonDuringScroll": "hideJumpToLatestButtonDuringScroll"; "displayDateSeparator": "displayDateSeparator"; "displayUnreadSeparator": "displayUnreadSeparator"; "dateSeparatorTextPos": "dateSeparatorTextPos"; "openMessageListAt": "openMessageListAt"; "hideUnreadCountForNotificationAndIndicator": "hideUnreadCountForNotificationAndIndicator"; "displayLoadingIndicator": "displayLoadingIndicator"; }, {}, never, never, false, never>;
}
