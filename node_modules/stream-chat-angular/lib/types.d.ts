import { TemplateRef } from '@angular/core';
import { Observable, Subject } from 'rxjs';
import type { Attachment, Channel, ChannelFilters, ChannelMemberResponse, CommandResponse, Event, ExtendableGenerics, FormatMessageResponse, LiteralStringForUnion, MessageResponseBase, Mute, ReactionGroupResponse, ReactionResponse, User, UserResponse } from 'stream-chat';
import { AttachmentService } from './attachment.service';
import { Icon } from './icon/icon.component';
export declare type UnknownType = Record<string, unknown>;
export declare type CustomTrigger = {
    [key: string]: {
        componentProps: UnknownType;
        data: UnknownType;
    };
};
export declare type DefaultStreamChatGenerics = ExtendableGenerics & {
    attachmentType: DefaultAttachmentType;
    channelType: DefaultChannelType;
    commandType: LiteralStringForUnion;
    eventType: UnknownType;
    messageType: DefaultMessageType;
    reactionType: UnknownType;
    userType: DefaultUserType;
};
export declare type DefaultAttachmentType = UnknownType & {
    asset_url?: string;
    id?: string;
    images?: Array<Attachment<DefaultStreamChatGenerics>>;
    mime_type?: string;
    isCustomAttachment?: boolean;
};
export declare type DefaultChannelType = UnknownType & {
    image?: string;
    member_count?: number;
    subtitle?: string;
};
export declare type DefaultCommandType = LiteralStringForUnion;
export declare type DefaultMessageType = UnknownType & {
    customType?: 'channel.intro' | 'message.date';
    date?: string | Date;
    errorStatusCode?: number;
    event?: Event<DefaultStreamChatGenerics>;
    unread?: boolean;
    readBy: UserResponse<DefaultStreamChatGenerics>[];
    translation?: string;
    quoted_message?: MessageResponseBase<DefaultStreamChatGenerics>;
};
export declare type DefaultUserTypeInternal = {
    image?: string;
    status?: string;
};
export declare type DefaultUserType = UnknownType & DefaultUserTypeInternal & {
    mutes?: Array<Mute<DefaultStreamChatGenerics>>;
};
export declare type StreamMessage<T extends DefaultStreamChatGenerics = DefaultStreamChatGenerics> = FormatMessageResponse<T>;
export declare type AttachmentUploadErrorReason = 'file-size' | 'file-extension' | 'unknown';
export declare type AttachmentUpload<T extends DefaultStreamChatGenerics = DefaultStreamChatGenerics> = {
    file: File;
    state: 'error' | 'success' | 'uploading';
    errorReason?: AttachmentUploadErrorReason;
    errorExtraInfo?: {
        param: string;
    }[];
    url?: string;
    type: 'image' | 'file' | 'video' | 'voiceRecording';
    previewUri?: string | ArrayBuffer;
    thumb_url?: string;
    extraData?: Partial<Attachment<T>>;
    fromAttachment?: Attachment<T>;
};
export declare type MentionAutcompleteListItemContext = {
    item: MentionAutcompleteListItem;
};
export declare type CommandAutocompleteListItemContext = {
    item: ComandAutocompleteListItem;
};
export declare type MentionAutcompleteListItem = (ChannelMemberResponse | UserResponse) & {
    autocompleteLabel: string;
};
export declare type ComandAutocompleteListItem = CommandResponse & {
    autocompleteLabel: string;
};
export declare type NotificationType = 'success' | 'error' | 'info';
export declare type NotificationPayload<T = object> = {
    id: string;
    type: NotificationType;
    text?: string;
    translateParams?: object;
    template?: TemplateRef<T>;
    templateContext?: T;
    dismissFn: () => void;
};
export declare type ChannelPreviewContext<T extends DefaultStreamChatGenerics = DefaultStreamChatGenerics> = {
    channel: Channel<T>;
};
export declare type ChannelPreviewInfoContext<T extends DefaultStreamChatGenerics = DefaultStreamChatGenerics> = ChannelPreviewContext & {
    latestMessage?: StreamMessage<T>;
    /**
     * The text of the latest message, or some meta information (for example: "Nothing yet")
     */
    latestMessageText: string;
    /**
     * The title of the channel, or the name of the channel members
     */
    channelDisplayTitle: string;
    /**
     * The status of the last message (only available if the last message was sent by the current user)
     */
    latestMessageStatus?: 'delivered' | 'read';
    /**
     * The time of the last message (formatted to a user-friendly string)
     */
    latestMessageTime?: string;
    unreadCount: number;
};
export declare type MentionTemplateContext = {
    content: string;
    user: UserResponse;
};
export declare type EmojiPickerContext = {
    emojiInput$: Subject<string>;
};
export declare type TypingIndicatorContext = {
    usersTyping$: Observable<UserResponse<DefaultStreamChatGenerics>[]>;
};
export declare type MessageContext = {
    message: StreamMessage | undefined;
    enabledMessageActions: string[];
    isLastSentMessage: boolean | undefined;
    mode: 'thread' | 'main';
    isHighlighted: boolean;
    customActions: CustomMessageActionItem[];
    scroll$?: Observable<void>;
};
export declare type ChannelActionsContext<T extends DefaultStreamChatGenerics = DefaultStreamChatGenerics> = {
    channel: Channel<T>;
};
export declare type CustomAttachmentListContext<T extends DefaultStreamChatGenerics = DefaultStreamChatGenerics> = {
    messageId: string;
    attachments: Attachment<T>[];
    parentMessageId?: string;
};
export declare type AttachmentListContext = CustomAttachmentListContext & {
    imageModalStateChangeHandler?: (state: 'opened' | 'closed') => void;
};
export declare type AvatarType = 'channel' | 'user';
export declare type AvatarLocation = 'channel-preview' | 'channel-header' | 'message-sender' | 'message-reader' | 'quoted-message-sender' | 'autocomplete-item' | 'typing-indicator'
/**
 * @deprecated this will be renamed to user-list in the next major release
 */
 | 'reaction';
export declare type AvatarContext = {
    name: string | undefined;
    imageUrl: string | undefined;
    type: AvatarType | undefined;
    location: AvatarLocation | undefined;
    channel?: Channel<DefaultStreamChatGenerics>;
    user?: User<DefaultStreamChatGenerics>;
    initialsType?: 'first-letter-of-first-word' | 'first-letter-of-each-word';
    showOnlineIndicator?: boolean;
};
export declare type AttachmentPreviewListContext = {
    attachmentUploads$: Observable<AttachmentUpload[]> | undefined;
    retryUploadHandler: (f: File) => void;
    deleteUploadHandler: (u: AttachmentUpload) => void;
    service: AttachmentService;
};
export declare type IconContext = {
    icon: Icon | undefined;
};
export declare type MessageActionsBoxContext<T extends DefaultStreamChatGenerics = DefaultStreamChatGenerics> = {
    isMine: boolean;
    message: StreamMessage<T> | undefined;
    enabledActions: string[];
    messageTextHtmlElement: HTMLElement | undefined;
};
export declare type MessageActionHandlerExtraParams = {
    isMine: boolean;
    messageTextHtmlElement?: HTMLElement;
};
export declare type MessageActionHandler<T extends DefaultStreamChatGenerics = DefaultStreamChatGenerics> = (message: StreamMessage<T>, params: MessageActionHandlerExtraParams) => void;
export declare type MessageActionBoxItemContext<T extends DefaultStreamChatGenerics = DefaultStreamChatGenerics> = {
    actionName: string;
    actionLabelOrTranslationKey: ((message: StreamMessage<T>) => string) | string;
    message: StreamMessage<T>;
    actionHandlerExtraParams: MessageActionHandlerExtraParams;
    actionHandler: MessageActionHandler<T>;
};
export declare type MessageReactionActionItem<T extends DefaultStreamChatGenerics = DefaultStreamChatGenerics> = {
    actionName: 'react';
    isVisible: (enabledActions: string[], isMine: boolean, message: StreamMessage<T>) => boolean;
};
declare type MessageActionItemBase<T extends DefaultStreamChatGenerics = DefaultStreamChatGenerics> = {
    actionLabelOrTranslationKey: ((message: StreamMessage<T>) => string) | string;
    isVisible: (enabledActions: string[], isMine: boolean, message: StreamMessage<T>) => boolean;
    actionHandler: MessageActionHandler;
};
export declare type MessageActionItem<T extends DefaultStreamChatGenerics = DefaultStreamChatGenerics> = MessageActionItemBase<T> & {
    actionName: 'quote' | 'pin' | 'flag' | 'edit' | 'delete' | 'mark-unread' | 'thread-reply' | 'copy-message-text';
};
export declare type CustomMessageActionItem<T extends DefaultStreamChatGenerics = DefaultStreamChatGenerics> = MessageActionItemBase<T> & {
    actionName: string;
};
export declare type MessageReactionsSelectorContext = {
    messageId: string | undefined;
    ownReactions: ReactionResponse<DefaultStreamChatGenerics>[];
};
export declare type MessageReactionsContext = {
    messageId: string | undefined;
    /** @deprecated use `messageReactionGroups` */
    messageReactionCounts: {
        [key in MessageReactionType]?: number;
    };
    /** @deprecated you can fetch the reactions using [`chatService.chatClient.queryReactions()`](/chat/docs/javascript/send_reaction/&q=queryReactions#query-reactions) */
    latestReactions: ReactionResponse<DefaultStreamChatGenerics>[];
    ownReactions: ReactionResponse<DefaultStreamChatGenerics>[];
    messageReactionGroups: {
        [key in MessageReactionType]: ReactionGroupResponse;
    };
};
export declare type ModalContext = {
    isOpen: boolean;
    isOpenChangeHandler: (isOpen: boolean) => void;
    content: TemplateRef<void>;
};
export declare type NotificationContext = {
    type: NotificationType | undefined;
    content: TemplateRef<void> | undefined;
};
export declare type ThreadHeaderContext = {
    parentMessage: StreamMessage | undefined;
    closeThreadHandler: () => void;
};
export declare type MessageReactionType = string;
export declare type AttachmentConfigration = {
    url: string;
    height: string;
    width: string;
};
export declare type ImageAttachmentConfiguration = AttachmentConfigration & {
    originalHeight: number;
    originalWidth: number;
};
export declare type VideoAttachmentConfiguration = ImageAttachmentConfiguration & {
    thumbUrl?: string;
};
export declare type DeliveredStatusContext = {
    message: StreamMessage;
};
export declare type SendingStatusContext = {
    message: StreamMessage;
};
export declare type CustomMetadataContext<T extends DefaultStreamChatGenerics = DefaultStreamChatGenerics> = {
    message: StreamMessage<T>;
};
export declare type ReadStatusContext = {
    message: StreamMessage;
    readByText: string;
};
export declare type ChannelHeaderInfoContext<T extends DefaultStreamChatGenerics = DefaultStreamChatGenerics> = {
    channel: Channel<T>;
};
export declare type CustomAttachmentUploadContext = {
    isMultipleFileUploadEnabled: boolean | undefined;
    attachmentService: AttachmentService;
};
export declare type AttachmentContext = {
    attachment: Attachment<DefaultStreamChatGenerics>;
};
export declare type SystemMessageContext = MessageContext & {
    parsedDate: string | undefined;
};
export declare type DateSeparatorContext = {
    date: Date;
    parsedDate: string;
};
export declare type UnreadMessagesIndicatorContext = {
    unreadCount: number;
};
export declare type UnreadMessagesNotificationContext = UnreadMessagesIndicatorContext & {
    onJump: () => void;
    onDismiss: () => void;
};
export declare type ChannelQueryState = {
    state: 'in-progress' | 'success' | 'error';
    error?: unknown;
};
export declare type MessageInput<T extends DefaultStreamChatGenerics = DefaultStreamChatGenerics> = {
    text: string;
    attachments: Attachment<T>[];
    mentionedUsers: UserResponse<T>[];
    parentId: string | undefined;
    quotedMessageId: string | undefined;
    customData: undefined | Partial<T['messageType']>;
};
export declare type OffsetNextPageConfiguration = {
    type: 'offset';
    offset: number;
};
export declare type FiltertNextPageConfiguration<T extends DefaultStreamChatGenerics = DefaultStreamChatGenerics> = {
    type: 'filter';
    paginationFilter: ChannelFilters<T>;
};
export declare type NextPageConfiguration = OffsetNextPageConfiguration | FiltertNextPageConfiguration | undefined;
export declare type MessageReactionClickDetails = {
    messageId: string;
    reactionType: string;
};
export declare type MessageActionsClickDetails<T extends DefaultStreamChatGenerics = DefaultStreamChatGenerics> = MessageActionsBoxContext<T> & {
    customActions: CustomMessageActionItem[];
};
export declare type GroupStyleOptions = {
    noGroupByUser?: boolean;
    lastReadMessageId?: string;
    noGroupByReadState?: boolean;
};
export declare type ChannelQueryType = 'first-page' | 'next-page' | 'recover-state';
export declare type ChannelQueryResult<T extends DefaultStreamChatGenerics = DefaultStreamChatGenerics> = {
    channels: Channel<T>[];
    hasMorePage: boolean;
};
export declare type VirtualizedListScrollPosition = 'top' | 'bottom' | 'middle';
export declare type VirtualizedListQueryState = {
    state: 'loading-top' | 'loading-bottom' | 'success' | 'error';
    error?: unknown;
};
export declare type VirtualizedListQueryDirection = 'top' | 'bottom';
export declare type VirtualizedListVerticalItemPosition = 'top' | 'bottom' | 'middle';
export declare type AudioRecording = MediaRecording & {
    waveform_data: number[];
};
export declare type MediaRecording = {
    recording: File;
    duration: number;
    mime_type: string;
    asset_url: string | ArrayBuffer | undefined;
};
export declare type CustomAttachmentPreviewListContext<T extends DefaultStreamChatGenerics = DefaultStreamChatGenerics> = {
    attachmentService: AttachmentService<T>;
};
export declare type ThreadReplyButtonContext<T extends DefaultStreamChatGenerics = DefaultStreamChatGenerics> = {
    message: StreamMessage<T>;
};
export declare type CustomAutocompleteItemContext = {
    item: CustomAutocompleteItem;
};
export declare type CustomAutocompleteItem = {
    /**
     * This is the text that will be inserted into the message input once a user selects an option (appended after the trigger character)
     */
    autocompleteLabel: string;
};
export declare type CustomAutocomplete = {
    /**
     * The character that will trigger the autocomplete (for example #)
     *
     * The SDK supports @ and / by default, so you can't use those
     */
    triggerCharacter: string;
    /**
     * The HTML template to display an item in the autocomplete list
     */
    templateRef: TemplateRef<{
        item: CustomAutocompleteItem;
    }>;
    /**
     * Set to `true` if space characters can be part of the `autocompleteLabel`
     */
    allowSpace: boolean;
    /**
     * The options to choose from
     *
     * In case you want to use dynamic/server-side filtering, use `updateOptions` instead
     */
    options: CustomAutocompleteItem[];
    /**
     * If you want to have dynamic/server-side filtering provide a  method that will be called any time the autocomplete options should be filtered
     * @param searchTerm the text to filter by (without the trigger character), can be an empty string
     * @returns a promise that will resolve to the options, you should take care of error handling
     */
    updateOptions?: (searchTerm: string) => Promise<CustomAutocompleteItem[]>;
};
export declare type MessageTextContext = {
    message: StreamMessage | undefined | MessageResponseBase;
    isQuoted: boolean;
    shouldTranslate: boolean;
};
export {};
