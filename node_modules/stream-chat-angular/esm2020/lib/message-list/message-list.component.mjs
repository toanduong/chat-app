import { ChangeDetectionStrategy, Component, HostBinding, Input, ViewChild, } from '@angular/core';
import { BehaviorSubject, Subject } from 'rxjs';
import { filter, map, shareReplay, take, tap, throttleTime, } from 'rxjs/operators';
import { getGroupStyles } from './group-styles';
import { listUsers } from '../list-users';
import { isOnSeparateDate } from '../is-on-separate-date';
import { VirtualizedMessageListService } from '../virtualized-message-list.service';
import { isSafari } from '../is-safari';
import * as i0 from "@angular/core";
import * as i1 from "../channel.service";
import * as i2 from "../chat-client.service";
import * as i3 from "../custom-templates.service";
import * as i4 from "../date-parser.service";
import * as i5 from "@angular/common";
import * as i6 from "../icon/icon.component";
import * as i7 from "../icon/icon-placeholder/icon-placeholder.component";
import * as i8 from "../icon/loading-indicator-placeholder/loading-indicator-placeholder.component";
import * as i9 from "../message/message.component";
import * as i10 from "@ngx-translate/core";
/**
 * The `MessageList` component renders a scrollable list of messages.
 */
export class MessageListComponent {
    constructor(channelService, chatClientService, customTemplatesService, dateParser, ngZone, cdRef) {
        this.channelService = channelService;
        this.chatClientService = chatClientService;
        this.customTemplatesService = customTemplatesService;
        this.dateParser = dateParser;
        this.ngZone = ngZone;
        this.cdRef = cdRef;
        /**
         * Determines if the message list should display channel messages or [thread messages](/chat/docs/javascript/threads/).
         */
        this.mode = 'main';
        /**
         * The direction of the messages in the list, `bottom-to-top` means newest message is at the bottom of the message list and users scroll upwards to load older messages
         */
        this.direction = 'bottom-to-top';
        /**
         * You can hide the "jump to latest" button while scrolling. A potential use-case for this input would be to [workaround a known issue on iOS Safar webview](https://github.com/GetStream/stream-chat-angular/issues/418)
         *
         */
        this.hideJumpToLatestButtonDuringScroll = false;
        /**
         * If `true` date separators will be displayed
         */
        this.displayDateSeparator = true;
        /**
         * If `true` unread indicator will be displayed
         */
        this.displayUnreadSeparator = true;
        /**
         * If date separators are displayed, you can set the horizontal position of the date text.
         */
        this.dateSeparatorTextPos = 'center';
        /**
         * `last-message` option will open the message list at the last message, `last-read-message` will open the list at the last unread message. This option only works if mode is `main`.
         */
        this.openMessageListAt = 'last-message';
        /**
         * If the user has unread messages when they open the channel the UI shows the unread indicator / notification which features the unread count by default. This count will be increased every time a user receives a new message. If you don't want to show the unread count, you can turn that off.
         *
         * This is only applicable for `main` mode, as threads doesn't have read infromation.
         */
        this.hideUnreadCountForNotificationAndIndicator = false;
        /**
         * You can turn on and off the loading indicator that signals to users that more messages are being loaded to the message list
         */
        this.displayLoadingIndicator = true;
        this.emptyMainMessageListTemplate = null;
        this.emptyThreadMessageListTemplate = null;
        this.enabledMessageActions = [];
        this.isEmpty = true;
        this.newMessageCountWhileBeingScrolled = 0;
        this.groupStyles = [];
        this.isNextMessageOnSeparateDate = [];
        this.loadingState = 'idle';
        this.isUnreadNotificationVisible = true;
        this.isJumpingToLatestUnreadMessage = false;
        this.isJumpToLatestButtonVisible = true;
        this.isJumpingToMessage = false;
        this.scroll$ = new Subject();
        this.isNewMessageSentByUser = false;
        this.subscriptions = [];
        this.isLatestMessageInList = true;
        this.parsedDates = new Map();
        this.isViewInited = false;
        this.jumpToMessageTimeouts = [];
        this.forceRepaintSubject = new Subject();
        this.isSafari = isSafari();
        this.scrollPosition$ = new BehaviorSubject('bottom');
        this.messageNotificationJumpClicked = () => {
            this.jumpToFirstUnreadMessage();
            this.isUnreadNotificationVisible = false;
        };
        this.messageNotificationDismissClicked = () => {
            this.isUnreadNotificationVisible = false;
        };
        this.usersTypingInChannel$ = this.channelService.usersTypingInChannel$;
        this.usersTypingInThread$ = this.channelService.usersTypingInThread$;
    }
    get class() {
        return `str-chat-angular__main-panel-inner str-chat-angular__message-list-host str-chat__main-panel-inner ${this.isEmpty ? 'str-chat-angular__message-list-host--empty' : ''}`;
    }
    ngOnInit() {
        this.subscriptions.push(this.forceRepaintSubject.pipe(throttleTime(1000)).subscribe(() => {
            this.forceRepaint();
        }));
        this.subscriptions.push(this.channelService.activeChannel$.subscribe((channel) => {
            let wasChannelSwitch = false;
            if (this.channelId !== channel?.id) {
                wasChannelSwitch = true;
                if (this.checkIfUnreadNotificationIsVisibleTimeout) {
                    clearTimeout(this.checkIfUnreadNotificationIsVisibleTimeout);
                }
                this.jumpToMessageTimeouts.forEach((timeout) => clearTimeout(timeout));
                this.jumpToMessageTimeouts = [];
                this.highlightedMessageId = undefined;
                this.isUnreadNotificationVisible = false;
                this.parsedDates = new Map();
                this.resetScrollState();
                this.setMessages$();
                this.channelId = channel?.id;
                if (this.isViewInited) {
                    this.cdRef.detectChanges();
                }
            }
            if (this.mode === 'main') {
                const lastReadMessageId = this.channelService.activeChannelLastReadMessageId;
                const unreadCount = this.channelService.activeChannelUnreadCount;
                if (lastReadMessageId !== this.lastReadMessageId ||
                    unreadCount !== this.unreadCount) {
                    this.lastReadMessageId = lastReadMessageId;
                    this.unreadCount = unreadCount || 0;
                    if (wasChannelSwitch && this.lastReadMessageId) {
                        // Delay jumping to last read message in case we need to give precedence to channelService.jumpToMessage
                        if (this.openMessageListAt === 'last-read-message') {
                            setTimeout(() => {
                                // Don't jump if a jump to a message was already started (using channelService.jumpToMessage)
                                if (!this.isJumpingToMessage &&
                                    !this.channelService.isMessageLoadingInProgress) {
                                    this.jumpToFirstUnreadMessage();
                                }
                            }, 0);
                        }
                        else {
                            // Wait till messages and the unread banner is rendered
                            // If unread banner isn't visible on the screen, we display the unread notificaion
                            setTimeout(() => {
                                const bannerElement = document.getElementById('stream-chat-new-message-indicator');
                                if (!bannerElement ||
                                    bannerElement?.offsetTop <
                                        this.scrollContainer?.nativeElement?.scrollHeight -
                                            this.scrollContainer?.nativeElement?.clientHeight) {
                                    this.isUnreadNotificationVisible = true;
                                    if (this.isViewInited) {
                                        this.cdRef.detectChanges();
                                    }
                                }
                            }, 100);
                        }
                    }
                    if (this.isViewInited) {
                        this.cdRef.detectChanges();
                    }
                }
            }
            else if (this.lastReadMessageId) {
                this.lastReadMessageId = undefined;
                this.unreadCount = 0;
                if (this.isViewInited) {
                    this.cdRef.detectChanges();
                }
            }
            const capabilites = channel?.data?.own_capabilities;
            const capabilitesString = [...(capabilites || [])].sort().join('');
            const enabledActionsString = [...(this.enabledMessageActions || [])]
                .sort()
                .join('');
            if (capabilitesString !== enabledActionsString) {
                this.enabledMessageActions = capabilites || [];
                if (this.isViewInited) {
                    this.cdRef.detectChanges();
                }
            }
            this.newMessageSubscription?.unsubscribe();
            if (channel) {
                this.newMessageSubscription = channel.on('message.new', (event) => {
                    if (!event.message) {
                        return;
                    }
                    else {
                        this.newMessageReceived(event.message);
                    }
                });
            }
        }));
        this.subscriptions.push(this.channelService.activeParentMessage$.subscribe((message) => {
            if (!message && this.parentMessage && this.mode === 'thread') {
                this.resetScrollState();
            }
            if (message &&
                this.parentMessage &&
                message.id !== this.parentMessage.id &&
                this.mode === 'thread') {
                this.resetScrollState();
                this.setMessages$();
            }
            if (this.parentMessage === message) {
                return;
            }
            this.parentMessage = message;
            if (this.isViewInited) {
                this.cdRef.detectChanges();
            }
        }));
        this.subscriptions.push(this.customTemplatesService.messageTemplate$.subscribe((template) => {
            if (this.messageTemplate === template) {
                return;
            }
            this.messageTemplate = template;
            if (this.isViewInited) {
                this.cdRef.detectChanges();
            }
        }));
        this.subscriptions.push(this.customTemplatesService.dateSeparatorTemplate$.subscribe((template) => {
            if (this.customDateSeparatorTemplate === template) {
                return;
            }
            this.customDateSeparatorTemplate = template;
            if (this.isViewInited) {
                this.cdRef.detectChanges();
            }
        }));
        this.subscriptions.push(this.customTemplatesService.newMessagesIndicatorTemplate$.subscribe((template) => {
            if (this.customnewMessagesIndicatorTemplate === template) {
                return;
            }
            this.customnewMessagesIndicatorTemplate = template;
            if (this.isViewInited) {
                this.cdRef.detectChanges();
            }
        }));
        this.subscriptions.push(this.customTemplatesService.newMessagesNotificationTemplate$.subscribe((template) => {
            if (this.customnewMessagesNotificationTemplate === template) {
                return;
            }
            this.customnewMessagesNotificationTemplate = template;
            if (this.isViewInited) {
                this.cdRef.detectChanges();
            }
        }));
        this.subscriptions.push(this.customTemplatesService.typingIndicatorTemplate$.subscribe((template) => {
            if (this.typingIndicatorTemplate === template) {
                return;
            }
            this.typingIndicatorTemplate = template;
            if (this.isViewInited) {
                this.cdRef.detectChanges();
            }
        }));
        this.subscriptions.push(this.customTemplatesService.emptyMainMessageListPlaceholder$.subscribe((template) => {
            const isChanged = this.emptyMainMessageListTemplate !== template;
            this.emptyMainMessageListTemplate = template || null;
            if (isChanged && this.isViewInited) {
                this.cdRef.detectChanges();
            }
        }));
        this.subscriptions.push(this.customTemplatesService.emptyThreadMessageListPlaceholder$.subscribe((template) => {
            const isChanged = this.emptyThreadMessageListTemplate !== template;
            this.emptyThreadMessageListTemplate = template || null;
            if (isChanged && this.isViewInited) {
                this.cdRef.detectChanges();
            }
        }));
        this.setMessages$();
    }
    ngOnChanges(changes) {
        if (changes.mode || changes.direction) {
            this.resetScrollState();
            this.setMessages$();
        }
        if (changes.direction) {
            if (this.scrollContainer?.nativeElement) {
                this.jumpToLatestMessage();
            }
        }
    }
    ngAfterViewInit() {
        this.isViewInited = true;
        this.ngZone.runOutsideAngular(() => {
            this.scrollContainer?.nativeElement?.addEventListener('scroll', () => this.scrolled());
        });
    }
    ngAfterViewChecked() {
        if (this.isJumpingToMessage) {
            this.isNewMessageSentByUser = false;
            this.messageIdToAnchorTo = undefined;
            this.anchorMessageTopOffset = undefined;
            return;
        }
        if (this.messageIdToAnchorTo && this.loadingState === 'idle') {
            this.preserveScrollbarPosition();
        }
        else if ((!this.isUserScrolled &&
            this.scrollContainer.nativeElement?.scrollHeight >
                this.scrollContainer?.nativeElement.clientHeight &&
            this.getScrollPosition() !==
                (this.direction === 'bottom-to-top' ? 'bottom' : 'top')) ||
            (this.isUserScrolled && this.isNewMessageSentByUser)) {
            this.isNewMessageSentByUser = false;
            this.jumpToLatestMessage();
        }
    }
    ngOnDestroy() {
        this.subscriptions.forEach((s) => s.unsubscribe());
        this.newMessageSubscription?.unsubscribe();
        if (this.scrollEndTimeout) {
            clearTimeout(this.scrollEndTimeout);
        }
        if (this.checkIfUnreadNotificationIsVisibleTimeout) {
            clearTimeout(this.checkIfUnreadNotificationIsVisibleTimeout);
        }
        if (this.jumpToLatestButtonVisibilityTimeout) {
            clearTimeout(this.jumpToLatestButtonVisibilityTimeout);
        }
        this.jumpToMessageTimeouts.forEach((timeout) => clearTimeout(timeout));
        this.disposeVirtualizedList();
    }
    trackByMessageId(_, item) {
        return item.id;
    }
    trackByUserId(_, user) {
        return user.id;
    }
    jumpToLatestMessage() {
        if (this.isLatestMessageInList) {
            this.direction === 'bottom-to-top'
                ? this.scrollToBottom()
                : this.scrollToTop();
        }
        else {
            void this.channelService.jumpToMessage('latest', this.mode === 'thread' ? this.parentMessage?.id : undefined);
        }
    }
    scrollToBottom() {
        this.scrollContainer.nativeElement.scrollTop =
            this.scrollContainer.nativeElement.scrollHeight + 0.1;
        if (this.isSafari) {
            this.forceRepaintSubject.next();
        }
    }
    scrollToTop() {
        this.scrollContainer.nativeElement.scrollTop = 0;
    }
    scrolled() {
        if (this.scrollContainer.nativeElement.scrollHeight ===
            this.scrollContainer.nativeElement.clientHeight) {
            if (this.isJumpToLatestButtonVisible) {
                this.isJumpToLatestButtonVisible = false;
                this.newMessageCountWhileBeingScrolled = 0;
                this.cdRef.detectChanges();
            }
            return;
        }
        if (this.scrollContainer.nativeElement.scrollHeight >
            this.scrollContainer.nativeElement.clientHeight) {
            if (!this.isJumpToLatestButtonVisible) {
                this.isJumpToLatestButtonVisible = true;
            }
        }
        this.scroll$.next();
        this.checkIfUserScrolled();
        if (this.hideJumpToLatestButtonDuringScroll) {
            if (this.isJumpToLatestButtonVisible) {
                this.isJumpToLatestButtonVisible = false;
                this.cdRef.detectChanges();
            }
            if (this.jumpToLatestButtonVisibilityTimeout) {
                clearTimeout(this.jumpToLatestButtonVisibilityTimeout);
            }
            this.jumpToLatestButtonVisibilityTimeout = setTimeout(() => {
                if (this.isUserScrolled) {
                    this.isJumpToLatestButtonVisible = true;
                    this.jumpToLatestButtonVisibilityTimeout = undefined;
                    this.cdRef.detectChanges();
                }
            }, 100);
        }
    }
    jumpToFirstUnreadMessage() {
        if (!this.lastReadMessageId) {
            return;
        }
        this.isJumpingToLatestUnreadMessage = true;
        void this.channelService.jumpToMessage(this.lastReadMessageId);
    }
    getTypingIndicatorContext() {
        return {
            usersTyping$: this.usersTyping$,
        };
    }
    getTypingIndicatorText(users) {
        const text = listUsers(users);
        return text;
    }
    isSentByCurrentUser(message) {
        if (!message) {
            return false;
        }
        return message.user?.id === this.chatClientService.chatClient.user?.id;
    }
    parseDate(date) {
        if (this.parsedDates.has(date)) {
            return this.parsedDates.get(date);
        }
        const parsedDate = this.dateParser.parseDate(date);
        this.parsedDates.set(date, parsedDate);
        return parsedDate;
    }
    get replyCountParam() {
        return { replyCount: this.parentMessage?.reply_count };
    }
    get emptyListTemplate() {
        return this.mode === 'main'
            ? this.emptyMainMessageListTemplate
            : this.emptyThreadMessageListTemplate;
    }
    checkIfUserScrolled() {
        let scrollPosition = this.getScrollPosition();
        const isUserScrolled = (this.direction === 'bottom-to-top'
            ? scrollPosition !== 'bottom'
            : scrollPosition !== 'top') || !this.isLatestMessageInList;
        if (this.isUserScrolled !== isUserScrolled) {
            this.ngZone.run(() => {
                this.isUserScrolled = isUserScrolled;
                if (!this.isUserScrolled) {
                    this.newMessageCountWhileBeingScrolled = 0;
                }
                this.cdRef.detectChanges();
            });
        }
        const prevScrollPosition = this.scrollPosition$.getValue();
        if (this.direction === 'top-to-bottom') {
            if (scrollPosition === 'top') {
                scrollPosition = 'bottom';
            }
            else if (scrollPosition === 'bottom') {
                scrollPosition = 'top';
            }
        }
        if (prevScrollPosition !== scrollPosition && !this.isJumpingToMessage) {
            if (scrollPosition === 'top' || scrollPosition === 'bottom') {
                this.virtualizedList?.virtualizedItems$
                    .pipe(take(1))
                    .subscribe((items) => {
                    this.messageIdToAnchorTo =
                        scrollPosition === 'top'
                            ? items[0]?.id
                            : items[items.length - 1]?.id;
                    this.anchorMessageTopOffset = document
                        .getElementById(this.messageIdToAnchorTo)
                        ?.getBoundingClientRect()?.top;
                });
            }
            this.ngZone.run(() => {
                this.scrollPosition$.next(scrollPosition);
            });
        }
    }
    preserveScrollbarPosition() {
        if (!this.messageIdToAnchorTo) {
            return;
        }
        const messageToAlignTo = document.getElementById(this.messageIdToAnchorTo);
        this.messageIdToAnchorTo = undefined;
        this.scrollContainer.nativeElement.scrollTop +=
            (messageToAlignTo?.getBoundingClientRect()?.top || 0) -
                (this.anchorMessageTopOffset || 0);
        this.anchorMessageTopOffset = undefined;
        if (this.isSafari) {
            this.forceRepaintSubject.next();
        }
    }
    forceRepaint() {
        // Solves the issue of empty screen on Safari when scrolling
        this.scrollContainer.nativeElement.style.display = 'none';
        this.scrollContainer.nativeElement.offsetHeight; // no need to store this anywhere, the reference is enough
        this.scrollContainer.nativeElement.style.display = '';
    }
    getScrollPosition() {
        let position = 'middle';
        if (Math.ceil(this.scrollContainer.nativeElement.scrollTop) +
            this.scrollContainer.nativeElement.clientHeight +
            1 >=
            this.scrollContainer.nativeElement.scrollHeight) {
            position = 'bottom';
        }
        else if (Math.floor(this.scrollContainer.nativeElement.scrollTop) <=
            (this.parentMessageElement?.nativeElement?.clientHeight || 0)) {
            position = 'top';
        }
        return position;
    }
    setMessages$() {
        this.disposeVirtualizedList();
        this.virtualizedList = new VirtualizedMessageListService(this.mode, this.scrollPosition$, this.channelService);
        this.queryStateSubscription = this.virtualizedList.queryState$.subscribe((queryState) => {
            let mappedState = 'idle';
            if (queryState.state.includes('loading')) {
                mappedState = queryState.state || 'loading-bottom';
            }
            if (mappedState !== this.loadingState) {
                this.loadingState = mappedState;
                if (this.isViewInited) {
                    this.cdRef.detectChanges();
                }
            }
        });
        this.messages$ = this.virtualizedList.virtualizedItems$.pipe(tap(() => {
            if (this.isEmpty) {
                // cdRef.detectChanges() isn't enough here, test will fail
                setTimeout(() => (this.isEmpty = false), 0);
            }
        }), tap((messages) => {
            if (this.isJumpingToLatestUnreadMessage &&
                !this.firstUnreadMessageId &&
                this.lastReadMessageId) {
                const lastReadIndex = messages.findIndex((m) => m.id === this.lastReadMessageId);
                if (lastReadIndex !== -1) {
                    this.firstUnreadMessageId = messages[lastReadIndex + 1]?.id;
                }
            }
        }), tap((messages) => (this.lastSentMessageId = [...messages]
            .reverse()
            .find((m) => m.user?.id === this.chatClientService.chatClient?.user?.id &&
            m.status !== 'sending')?.id)), tap((messages) => {
            const latestMessageInList = messages[messages.length - 1];
            const channel = this.channelService.activeChannel;
            const messagesFromState = (this.mode === 'main'
                ? channel?.state.latestMessages
                : channel?.state.threads[this.parentMessage?.id || '']) || [];
            this.isLatestMessageInList =
                !latestMessageInList ||
                    latestMessageInList.cid !== channel?.cid ||
                    (this.mode === 'thread' &&
                        latestMessageInList?.parent_id !== this.parentMessage?.id) ||
                    latestMessageInList?.id ===
                        messagesFromState[messagesFromState.length - 1]?.id;
            if (!this.isLatestMessageInList) {
                this.isUserScrolled = true;
            }
        }), map((messages) => {
            return this.direction === 'bottom-to-top'
                ? messages
                : [...messages].reverse();
        }), tap((messages) => {
            this.groupStyles = messages.map((m, i) => getGroupStyles(m, messages[i - 1], messages[i + 1], {
                lastReadMessageId: this.lastReadMessageId,
            }));
            this.isNextMessageOnSeparateDate = messages.map((m, i) => this.checkIfOnSeparateDates(m, messages[i + 1]));
        }), shareReplay(1));
        if (this.virtualizedList?.jumpToItem$) {
            this.jumpToItemSubscription = this.virtualizedList.jumpToItem$
                .pipe(filter((jumpToMessage) => !!jumpToMessage.item?.id))
                .subscribe((jumpToMessage) => {
                let messageId = jumpToMessage.item?.id;
                if (messageId) {
                    if (this.isJumpingToLatestUnreadMessage) {
                        messageId = this.firstUnreadMessageId || messageId;
                    }
                    if (jumpToMessage.position !== 'bottom') {
                        this.highlightedMessageId = messageId;
                    }
                    else if (this.direction === 'top-to-bottom') {
                        jumpToMessage.position = 'top';
                    }
                    this.isJumpingToMessage = true;
                    this.scrollMessageIntoView({
                        messageId: this.firstUnreadMessageId || messageId,
                        position: jumpToMessage.position || 'middle',
                    });
                }
            });
        }
    }
    resetScrollState() {
        this.isEmpty = true;
        this.isUserScrolled = false;
        this.messageIdToAnchorTo = undefined;
        this.anchorMessageTopOffset = undefined;
        this.newMessageCountWhileBeingScrolled = 0;
        this.isNewMessageSentByUser = false;
        this.isLatestMessageInList = true;
        this.isJumpingToMessage = false;
        this.scrollPosition$.next('bottom');
        this.loadingState = 'idle';
    }
    disposeVirtualizedList() {
        this.virtualizedList?.dispose();
        this.jumpToItemSubscription?.unsubscribe();
        this.queryStateSubscription?.unsubscribe();
    }
    get usersTyping$() {
        return this.mode === 'thread'
            ? this.usersTypingInThread$
            : this.usersTypingInChannel$;
    }
    scrollMessageIntoView(options, withRetry = true) {
        const element = document.getElementById(options.messageId);
        this.jumpToMessageTimeouts.forEach((t) => clearTimeout(t));
        this.jumpToMessageTimeouts = [];
        if (!element && withRetry) {
            // If the message was newly inserted into activeChannelMessages$, the message will be rendered after the current change detection cycle -> wait for this cycle to complete
            this.jumpToMessageTimeouts.push(setTimeout(() => this.scrollMessageIntoView(options, false)));
        }
        else if (element) {
            const blockMapping = {
                top: 'start',
                bottom: 'end',
                middle: 'center',
            };
            // We can't know when smooth scrolling ends, so we set the behavior to instant https://github.com/w3c/csswg-drafts/issues/3744
            element.scrollIntoView({
                behavior: 'instant',
                block: blockMapping[options.position],
            });
            if (options.position !== 'middle') {
                options.position === 'bottom'
                    ? this.scrollToBottom()
                    : this.scrollToTop();
            }
            this.jumpToMessageTimeouts.push(setTimeout(() => {
                this.isJumpingToMessage = false;
                if (!this.isUserScrolled) {
                    this.checkIfUserScrolled();
                }
            }, 200));
            this.jumpToMessageTimeouts.push(setTimeout(() => {
                this.highlightedMessageId = undefined;
                this.firstUnreadMessageId = undefined;
                this.isJumpingToLatestUnreadMessage = false;
                this.jumpToMessageTimeouts = [];
                this.cdRef.detectChanges();
            }, 1000));
        }
        else {
            this.isJumpingToMessage = false;
            this.highlightedMessageId = undefined;
            this.firstUnreadMessageId = undefined;
            this.isJumpingToLatestUnreadMessage = false;
        }
    }
    newMessageReceived(message) {
        if ((this.mode === 'main' && message.parent_id) ||
            (this.mode === 'thread' && message.parent_id !== this.parentMessage?.id)) {
            return;
        }
        const isNewMessageSentByCurrentUser = message.user?.id === this.chatClientService.chatClient?.user?.id;
        let shouldDetectChanges = false;
        if (!this.isNewMessageSentByUser && isNewMessageSentByCurrentUser) {
            this.isNewMessageSentByUser = true;
            shouldDetectChanges = true;
        }
        if (this.isUserScrolled) {
            this.newMessageCountWhileBeingScrolled++;
            shouldDetectChanges = true;
        }
        if (!this.isNewMessageSentByUser && this.unreadCount !== undefined) {
            this.unreadCount++;
            shouldDetectChanges = true;
        }
        if (shouldDetectChanges && this.isViewInited) {
            this.cdRef.detectChanges();
        }
    }
    checkIfOnSeparateDates(message, nextMessage) {
        if (!message || !nextMessage) {
            return false;
        }
        return isOnSeparateDate(message.created_at, nextMessage.created_at);
    }
}
MessageListComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: MessageListComponent, deps: [{ token: i1.ChannelService }, { token: i2.ChatClientService }, { token: i3.CustomTemplatesService }, { token: i4.DateParserService }, { token: i0.NgZone }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
MessageListComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.4", type: MessageListComponent, selector: "stream-message-list", inputs: { mode: "mode", direction: "direction", hideJumpToLatestButtonDuringScroll: "hideJumpToLatestButtonDuringScroll", displayDateSeparator: "displayDateSeparator", displayUnreadSeparator: "displayUnreadSeparator", dateSeparatorTextPos: "dateSeparatorTextPos", openMessageListAt: "openMessageListAt", hideUnreadCountForNotificationAndIndicator: "hideUnreadCountForNotificationAndIndicator", displayLoadingIndicator: "displayLoadingIndicator" }, host: { properties: { "class": "this.class" } }, viewQueries: [{ propertyName: "scrollContainer", first: true, predicate: ["scrollContainer"], descendants: true }, { propertyName: "parentMessageElement", first: true, predicate: ["parentMessageElement"], descendants: true }], usesOnChanges: true, ngImport: i0, template: "<ng-container\n  *ngIf=\"\n    lastReadMessageId &&\n    isUnreadNotificationVisible &&\n    openMessageListAt === 'last-message' &&\n    displayUnreadSeparator\n  \"\n>\n  <ng-container\n    *ngTemplateOutlet=\"\n      customnewMessagesNotificationTemplate ||\n        defaultUnreadMessagesNotification;\n      context: {\n        unreadCount: unreadCount,\n        onDismiss: messageNotificationDismissClicked,\n        onJump: messageNotificationJumpClicked\n      }\n    \"\n  ></ng-container>\n</ng-container>\n<ng-template\n  #defaultUnreadMessagesNotification\n  let-unreadCount=\"unreadCount\"\n  let-onDismiss=\"onDismiss\"\n  let-onJump=\"onJump\"\n>\n  <div\n    class=\"str-chat__unread-messages-notification\"\n    data-testid=\"unread-messages-notification\"\n  >\n    <button\n      data-testid=\"unread-messages-notification-jump-to-message\"\n      (click)=\"onJump()\"\n    >\n      <ng-container\n        *ngIf=\"\n          unreadCount > 0 && !hideUnreadCountForNotificationAndIndicator;\n          else noUnreadCount\n        \"\n      >\n        {{\n          (unreadCount === 1\n            ? \"streamChat.\\{\\{count\\}\\} unread message\"\n            : \"streamChat.\\{\\{count\\}\\} unread messages\"\n          ) | translate : { count: unreadCount }\n        }}\n      </ng-container>\n      <ng-template #noUnreadCount>\n        {{ \"streamChat.Unread messages\" | translate }}\n      </ng-template>\n    </button>\n    <button\n      data-testid=\"unread-messages-notification-dismiss\"\n      (click)=\"onDismiss()\"\n    >\n      <stream-icon-placeholder icon=\"close\"></stream-icon-placeholder>\n    </button>\n  </div>\n</ng-template>\n<div #scrollContainer data-testid=\"scroll-container\" class=\"str-chat__list\">\n  <ng-container *ngIf=\"mode === 'main' && isEmpty && emptyListTemplate\">\n    <ng-container *ngTemplateOutlet=\"emptyListTemplate\"></ng-container>\n  </ng-container>\n  <div class=\"str-chat__reverse-infinite-scroll str-chat__message-list-scroll\">\n    <ul class=\"str-chat__ul\">\n      <li\n        *ngIf=\"mode === 'thread' && parentMessage\"\n        #parentMessageElement\n        data-testid=\"parent-message\"\n        class=\"str-chat__parent-message-li\"\n      >\n        <ng-container\n          *ngTemplateOutlet=\"\n            messageTemplateContainer;\n            context: { message: parentMessage, index: 'parent' }\n          \"\n        ></ng-container>\n        <div data-testid=\"reply-count\" class=\"str-chat__thread-start\">\n          {{parentMessage.reply_count === 1 ? ('streamChat.1 reply' | translate) : ('streamChat.{{ replyCount }}\n          replies' | translate:replyCountParam)}}\n        </div>\n      </li>\n      <ng-container *ngIf=\"mode === 'thread' && isEmpty && emptyListTemplate\">\n        <ng-container *ngTemplateOutlet=\"emptyListTemplate\"></ng-container>\n      </ng-container>\n      <stream-loading-indicator-placeholder\n        *ngIf=\"\n          ((loadingState === 'loading-top' && direction === 'bottom-to-top') ||\n            (loadingState === 'loading-bottom' &&\n              direction === 'top-to-bottom')) &&\n            displayLoadingIndicator;\n          else loadingIndicatorPlaceholder\n        \"\n        data-testid=\"top-loading-indicator\"\n      ></stream-loading-indicator-placeholder>\n      <ng-container *ngIf=\"messages$ | async as messages\">\n        <ng-container\n          *ngFor=\"\n            let message of messages;\n            let i = index;\n            let isFirst = first;\n            let isLast = last;\n            trackBy: trackByMessageId\n          \"\n        >\n          <ng-container *ngIf=\"isFirst\">\n            <ng-container\n              *ngTemplateOutlet=\"\n                dateSeparator;\n                context: {\n                  date: message.created_at,\n                  parsedDate: parseDate(message.created_at)\n                }\n              \"\n            ></ng-container>\n          </ng-container>\n          <li\n            tabindex=\"0\"\n            data-testclass=\"message\"\n            class=\"str-chat__li str-chat__li--{{ groupStyles[i] }}\"\n            id=\"{{ message.id }}\"\n          >\n            <ng-container\n              *ngTemplateOutlet=\"\n                messageTemplateContainer;\n                context: { message: message, index: i }\n              \"\n            ></ng-container>\n          </li>\n          <ng-container\n            *ngIf=\"\n              (lastReadMessageId === message?.id &&\n                direction === 'bottom-to-top') ||\n              (direction === 'top-to-bottom' &&\n                lastReadMessageId === messages[i + 1]?.id)\n            \"\n          >\n            <li\n              *ngIf=\"displayUnreadSeparator\"\n              id=\"stream-chat-new-message-indicator\"\n              data-testid=\"new-messages-indicator\"\n              class=\"str-chat__li str-chat__unread-messages-separator-wrapper\"\n            >\n              <ng-container\n                *ngTemplateOutlet=\"\n                  customnewMessagesIndicatorTemplate ||\n                    defaultNewMessagesIndicator;\n                  context: { unreadCount: unreadCount }\n                \"\n              ></ng-container>\n            </li>\n          </ng-container>\n          <ng-container *ngIf=\"isNextMessageOnSeparateDate[i]\">\n            <ng-container\n              *ngTemplateOutlet=\"\n                dateSeparator;\n                context: {\n                  date: messages[i + 1].created_at,\n                  parsedDate: parseDate(messages[i + 1].created_at)\n                }\n              \"\n            ></ng-container>\n          </ng-container>\n        </ng-container>\n      </ng-container>\n      <stream-loading-indicator-placeholder\n        *ngIf=\"\n          ((loadingState === 'loading-bottom' &&\n            direction === 'bottom-to-top') ||\n            (loadingState === 'loading-top' &&\n              direction === 'top-to-bottom')) &&\n            displayLoadingIndicator;\n          else loadingIndicatorPlaceholder\n        \"\n        data-testid=\"bottom-loading-indicator\"\n      ></stream-loading-indicator-placeholder>\n      <ng-template #loadingIndicatorPlaceholder>\n        <div class=\"str-chat__loading-indicator-placeholder\"></div>\n      </ng-template>\n    </ul>\n    <ng-template #defaultTypingIndicator let-usersTyping$=\"usersTyping$\">\n      <!-- eslint-disable-next-line @angular-eslint/template/no-any -->\n      <ng-container *ngIf=\"$any(usersTyping$ | async) as users\">\n        <div\n          *ngIf=\"users.length > 0\"\n          data-testid=\"typing-indicator\"\n          class=\"str-chat__typing-indicator str-chat__typing-indicator--typing\"\n        >\n          <div class=\"str-chat__typing-indicator__dots\">\n            <span class=\"str-chat__typing-indicator__dot\"></span>\n            <span class=\"str-chat__typing-indicator__dot\"></span>\n            <span class=\"str-chat__typing-indicator__dot\"></span>\n          </div>\n          <div\n            data-testid=\"typing-users\"\n            class=\"str-chat__typing-indicator__users\"\n          >\n            {{\n              users.length === 1\n                ? (\"streamChat.user is typing\"\n                  | translate : { user: getTypingIndicatorText(users) })\n                : (\"streamChat.users are typing\"\n                  | translate : { users: getTypingIndicatorText(users) })\n            }}\n          </div>\n        </div>\n      </ng-container>\n    </ng-template>\n    <ng-container\n      *ngTemplateOutlet=\"\n        typingIndicatorTemplate || defaultTypingIndicator;\n        context: getTypingIndicatorContext()\n      \"\n    ></ng-container>\n  </div>\n</div>\n<div class=\"str-chat__jump-to-latest-message\">\n  <button\n    *ngIf=\"isUserScrolled && isJumpToLatestButtonVisible\"\n    data-testid=\"scroll-to-latest\"\n    class=\"str-chat__message-notification-scroll-to-latest str-chat__message-notification-scroll-to-latest-right str-chat__circle-fab\"\n    (keyup.enter)=\"jumpToLatestMessage()\"\n    (click)=\"jumpToLatestMessage()\"\n  >\n    <stream-icon\n      class=\"str-chat__jump-to-latest-icon str-chat__circle-fab-icon\"\n      [icon]=\"direction === 'bottom-to-top' ? 'arrow-down' : 'arrow-up'\"\n    ></stream-icon>\n    <div\n      *ngIf=\"newMessageCountWhileBeingScrolled > 0\"\n      class=\"str-chat__message-notification str-chat__message-notification-scroll-to-latest-unread-count str-chat__jump-to-latest-unread-count\"\n    >\n      {{ newMessageCountWhileBeingScrolled }}\n    </div>\n  </button>\n</div>\n\n<ng-template #messageTemplateContainer let-message=\"message\" let-index=\"index\">\n  <ng-template\n    #defaultMessageTemplate\n    let-messageInput=\"message\"\n    let-isLastSentMessage=\"isLastSentMessage\"\n    let-enabledMessageActions=\"enabledMessageActions\"\n    let-mode=\"mode\"\n    let-isHighlighted=\"isHighlighted\"\n    let-scroll$=\"scroll$\"\n  >\n    <stream-message\n      [message]=\"messageInput\"\n      [isLastSentMessage]=\"isLastSentMessage\"\n      [enabledMessageActions]=\"enabledMessageActions\"\n      [mode]=\"mode\"\n      [isHighlighted]=\"isHighlighted\"\n      [scroll$]=\"scroll$\"\n    ></stream-message>\n  </ng-template>\n  <ng-container\n    *ngTemplateOutlet=\"\n      messageTemplate || defaultMessageTemplate;\n      context: {\n        message: message,\n        isLastSentMessage: !!(\n          lastSentMessageId && message?.id === lastSentMessageId\n        ),\n        enabledMessageActions: enabledMessageActions,\n        mode: mode,\n        isHighlighted: message?.id === highlightedMessageId,\n        scroll$: scroll$\n      }\n    \"\n  ></ng-container>\n</ng-template>\n\n<ng-template #dateSeparator let-date=\"date\" let-parsedDate=\"parsedDate\">\n  <ng-container *ngIf=\"displayDateSeparator\">\n    <ng-container\n      *ngTemplateOutlet=\"\n        customDateSeparatorTemplate || defaultDateSeparator;\n        context: {\n          date: date,\n          parsedDate: parsedDate\n        }\n      \"\n    ></ng-container>\n  </ng-container>\n\n  <ng-template\n    #defaultDateSeparator\n    let-date=\"date\"\n    let-parsedDate=\"parsedDate\"\n  >\n    <div data-testid=\"date-separator\" class=\"str-chat__date-separator\">\n      <hr\n        *ngIf=\"\n          dateSeparatorTextPos === 'right' || dateSeparatorTextPos === 'center'\n        \"\n        class=\"str-chat__date-separator-line\"\n      />\n      <div class=\"str-chat__date-separator-date\">\n        {{ parsedDate }}\n      </div>\n      <hr\n        *ngIf=\"\n          dateSeparatorTextPos === 'left' || dateSeparatorTextPos === 'center'\n        \"\n        class=\"str-chat__date-separator-line\"\n      />\n    </div>\n  </ng-template>\n</ng-template>\n\n<ng-template #defaultNewMessagesIndicator let-unreadCount=\"unreadCount\">\n  <div class=\"str-chat__unread-messages-separator\">\n    <ng-container\n      *ngIf=\"\n        unreadCount > 0 && !hideUnreadCountForNotificationAndIndicator;\n        else noUnreadCount\n      \"\n    >\n      {{\n        (unreadCount === 1\n          ? \"streamChat.\\{\\{count\\}\\} unread message\"\n          : \"streamChat.\\{\\{count\\}\\} unread messages\"\n        ) | translate : { count: unreadCount }\n      }}\n    </ng-container>\n    <ng-template #noUnreadCount>\n      {{ \"streamChat.Unread messages\" | translate }}\n    </ng-template>\n  </div>\n</ng-template>\n", dependencies: [{ kind: "directive", type: i5.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i5.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i5.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: i6.IconComponent, selector: "stream-icon", inputs: ["icon"] }, { kind: "component", type: i7.IconPlaceholderComponent, selector: "stream-icon-placeholder", inputs: ["icon"] }, { kind: "component", type: i8.LoadingIndicatorPlaceholderComponent, selector: "stream-loading-indicator-placeholder" }, { kind: "component", type: i9.MessageComponent, selector: "stream-message", inputs: ["message", "enabledMessageActions", "isLastSentMessage", "mode", "isHighlighted", "scroll$"] }, { kind: "pipe", type: i5.AsyncPipe, name: "async" }, { kind: "pipe", type: i10.TranslatePipe, name: "translate" }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: MessageListComponent, decorators: [{
            type: Component,
            args: [{ selector: 'stream-message-list', changeDetection: ChangeDetectionStrategy.OnPush, template: "<ng-container\n  *ngIf=\"\n    lastReadMessageId &&\n    isUnreadNotificationVisible &&\n    openMessageListAt === 'last-message' &&\n    displayUnreadSeparator\n  \"\n>\n  <ng-container\n    *ngTemplateOutlet=\"\n      customnewMessagesNotificationTemplate ||\n        defaultUnreadMessagesNotification;\n      context: {\n        unreadCount: unreadCount,\n        onDismiss: messageNotificationDismissClicked,\n        onJump: messageNotificationJumpClicked\n      }\n    \"\n  ></ng-container>\n</ng-container>\n<ng-template\n  #defaultUnreadMessagesNotification\n  let-unreadCount=\"unreadCount\"\n  let-onDismiss=\"onDismiss\"\n  let-onJump=\"onJump\"\n>\n  <div\n    class=\"str-chat__unread-messages-notification\"\n    data-testid=\"unread-messages-notification\"\n  >\n    <button\n      data-testid=\"unread-messages-notification-jump-to-message\"\n      (click)=\"onJump()\"\n    >\n      <ng-container\n        *ngIf=\"\n          unreadCount > 0 && !hideUnreadCountForNotificationAndIndicator;\n          else noUnreadCount\n        \"\n      >\n        {{\n          (unreadCount === 1\n            ? \"streamChat.\\{\\{count\\}\\} unread message\"\n            : \"streamChat.\\{\\{count\\}\\} unread messages\"\n          ) | translate : { count: unreadCount }\n        }}\n      </ng-container>\n      <ng-template #noUnreadCount>\n        {{ \"streamChat.Unread messages\" | translate }}\n      </ng-template>\n    </button>\n    <button\n      data-testid=\"unread-messages-notification-dismiss\"\n      (click)=\"onDismiss()\"\n    >\n      <stream-icon-placeholder icon=\"close\"></stream-icon-placeholder>\n    </button>\n  </div>\n</ng-template>\n<div #scrollContainer data-testid=\"scroll-container\" class=\"str-chat__list\">\n  <ng-container *ngIf=\"mode === 'main' && isEmpty && emptyListTemplate\">\n    <ng-container *ngTemplateOutlet=\"emptyListTemplate\"></ng-container>\n  </ng-container>\n  <div class=\"str-chat__reverse-infinite-scroll str-chat__message-list-scroll\">\n    <ul class=\"str-chat__ul\">\n      <li\n        *ngIf=\"mode === 'thread' && parentMessage\"\n        #parentMessageElement\n        data-testid=\"parent-message\"\n        class=\"str-chat__parent-message-li\"\n      >\n        <ng-container\n          *ngTemplateOutlet=\"\n            messageTemplateContainer;\n            context: { message: parentMessage, index: 'parent' }\n          \"\n        ></ng-container>\n        <div data-testid=\"reply-count\" class=\"str-chat__thread-start\">\n          {{parentMessage.reply_count === 1 ? ('streamChat.1 reply' | translate) : ('streamChat.{{ replyCount }}\n          replies' | translate:replyCountParam)}}\n        </div>\n      </li>\n      <ng-container *ngIf=\"mode === 'thread' && isEmpty && emptyListTemplate\">\n        <ng-container *ngTemplateOutlet=\"emptyListTemplate\"></ng-container>\n      </ng-container>\n      <stream-loading-indicator-placeholder\n        *ngIf=\"\n          ((loadingState === 'loading-top' && direction === 'bottom-to-top') ||\n            (loadingState === 'loading-bottom' &&\n              direction === 'top-to-bottom')) &&\n            displayLoadingIndicator;\n          else loadingIndicatorPlaceholder\n        \"\n        data-testid=\"top-loading-indicator\"\n      ></stream-loading-indicator-placeholder>\n      <ng-container *ngIf=\"messages$ | async as messages\">\n        <ng-container\n          *ngFor=\"\n            let message of messages;\n            let i = index;\n            let isFirst = first;\n            let isLast = last;\n            trackBy: trackByMessageId\n          \"\n        >\n          <ng-container *ngIf=\"isFirst\">\n            <ng-container\n              *ngTemplateOutlet=\"\n                dateSeparator;\n                context: {\n                  date: message.created_at,\n                  parsedDate: parseDate(message.created_at)\n                }\n              \"\n            ></ng-container>\n          </ng-container>\n          <li\n            tabindex=\"0\"\n            data-testclass=\"message\"\n            class=\"str-chat__li str-chat__li--{{ groupStyles[i] }}\"\n            id=\"{{ message.id }}\"\n          >\n            <ng-container\n              *ngTemplateOutlet=\"\n                messageTemplateContainer;\n                context: { message: message, index: i }\n              \"\n            ></ng-container>\n          </li>\n          <ng-container\n            *ngIf=\"\n              (lastReadMessageId === message?.id &&\n                direction === 'bottom-to-top') ||\n              (direction === 'top-to-bottom' &&\n                lastReadMessageId === messages[i + 1]?.id)\n            \"\n          >\n            <li\n              *ngIf=\"displayUnreadSeparator\"\n              id=\"stream-chat-new-message-indicator\"\n              data-testid=\"new-messages-indicator\"\n              class=\"str-chat__li str-chat__unread-messages-separator-wrapper\"\n            >\n              <ng-container\n                *ngTemplateOutlet=\"\n                  customnewMessagesIndicatorTemplate ||\n                    defaultNewMessagesIndicator;\n                  context: { unreadCount: unreadCount }\n                \"\n              ></ng-container>\n            </li>\n          </ng-container>\n          <ng-container *ngIf=\"isNextMessageOnSeparateDate[i]\">\n            <ng-container\n              *ngTemplateOutlet=\"\n                dateSeparator;\n                context: {\n                  date: messages[i + 1].created_at,\n                  parsedDate: parseDate(messages[i + 1].created_at)\n                }\n              \"\n            ></ng-container>\n          </ng-container>\n        </ng-container>\n      </ng-container>\n      <stream-loading-indicator-placeholder\n        *ngIf=\"\n          ((loadingState === 'loading-bottom' &&\n            direction === 'bottom-to-top') ||\n            (loadingState === 'loading-top' &&\n              direction === 'top-to-bottom')) &&\n            displayLoadingIndicator;\n          else loadingIndicatorPlaceholder\n        \"\n        data-testid=\"bottom-loading-indicator\"\n      ></stream-loading-indicator-placeholder>\n      <ng-template #loadingIndicatorPlaceholder>\n        <div class=\"str-chat__loading-indicator-placeholder\"></div>\n      </ng-template>\n    </ul>\n    <ng-template #defaultTypingIndicator let-usersTyping$=\"usersTyping$\">\n      <!-- eslint-disable-next-line @angular-eslint/template/no-any -->\n      <ng-container *ngIf=\"$any(usersTyping$ | async) as users\">\n        <div\n          *ngIf=\"users.length > 0\"\n          data-testid=\"typing-indicator\"\n          class=\"str-chat__typing-indicator str-chat__typing-indicator--typing\"\n        >\n          <div class=\"str-chat__typing-indicator__dots\">\n            <span class=\"str-chat__typing-indicator__dot\"></span>\n            <span class=\"str-chat__typing-indicator__dot\"></span>\n            <span class=\"str-chat__typing-indicator__dot\"></span>\n          </div>\n          <div\n            data-testid=\"typing-users\"\n            class=\"str-chat__typing-indicator__users\"\n          >\n            {{\n              users.length === 1\n                ? (\"streamChat.user is typing\"\n                  | translate : { user: getTypingIndicatorText(users) })\n                : (\"streamChat.users are typing\"\n                  | translate : { users: getTypingIndicatorText(users) })\n            }}\n          </div>\n        </div>\n      </ng-container>\n    </ng-template>\n    <ng-container\n      *ngTemplateOutlet=\"\n        typingIndicatorTemplate || defaultTypingIndicator;\n        context: getTypingIndicatorContext()\n      \"\n    ></ng-container>\n  </div>\n</div>\n<div class=\"str-chat__jump-to-latest-message\">\n  <button\n    *ngIf=\"isUserScrolled && isJumpToLatestButtonVisible\"\n    data-testid=\"scroll-to-latest\"\n    class=\"str-chat__message-notification-scroll-to-latest str-chat__message-notification-scroll-to-latest-right str-chat__circle-fab\"\n    (keyup.enter)=\"jumpToLatestMessage()\"\n    (click)=\"jumpToLatestMessage()\"\n  >\n    <stream-icon\n      class=\"str-chat__jump-to-latest-icon str-chat__circle-fab-icon\"\n      [icon]=\"direction === 'bottom-to-top' ? 'arrow-down' : 'arrow-up'\"\n    ></stream-icon>\n    <div\n      *ngIf=\"newMessageCountWhileBeingScrolled > 0\"\n      class=\"str-chat__message-notification str-chat__message-notification-scroll-to-latest-unread-count str-chat__jump-to-latest-unread-count\"\n    >\n      {{ newMessageCountWhileBeingScrolled }}\n    </div>\n  </button>\n</div>\n\n<ng-template #messageTemplateContainer let-message=\"message\" let-index=\"index\">\n  <ng-template\n    #defaultMessageTemplate\n    let-messageInput=\"message\"\n    let-isLastSentMessage=\"isLastSentMessage\"\n    let-enabledMessageActions=\"enabledMessageActions\"\n    let-mode=\"mode\"\n    let-isHighlighted=\"isHighlighted\"\n    let-scroll$=\"scroll$\"\n  >\n    <stream-message\n      [message]=\"messageInput\"\n      [isLastSentMessage]=\"isLastSentMessage\"\n      [enabledMessageActions]=\"enabledMessageActions\"\n      [mode]=\"mode\"\n      [isHighlighted]=\"isHighlighted\"\n      [scroll$]=\"scroll$\"\n    ></stream-message>\n  </ng-template>\n  <ng-container\n    *ngTemplateOutlet=\"\n      messageTemplate || defaultMessageTemplate;\n      context: {\n        message: message,\n        isLastSentMessage: !!(\n          lastSentMessageId && message?.id === lastSentMessageId\n        ),\n        enabledMessageActions: enabledMessageActions,\n        mode: mode,\n        isHighlighted: message?.id === highlightedMessageId,\n        scroll$: scroll$\n      }\n    \"\n  ></ng-container>\n</ng-template>\n\n<ng-template #dateSeparator let-date=\"date\" let-parsedDate=\"parsedDate\">\n  <ng-container *ngIf=\"displayDateSeparator\">\n    <ng-container\n      *ngTemplateOutlet=\"\n        customDateSeparatorTemplate || defaultDateSeparator;\n        context: {\n          date: date,\n          parsedDate: parsedDate\n        }\n      \"\n    ></ng-container>\n  </ng-container>\n\n  <ng-template\n    #defaultDateSeparator\n    let-date=\"date\"\n    let-parsedDate=\"parsedDate\"\n  >\n    <div data-testid=\"date-separator\" class=\"str-chat__date-separator\">\n      <hr\n        *ngIf=\"\n          dateSeparatorTextPos === 'right' || dateSeparatorTextPos === 'center'\n        \"\n        class=\"str-chat__date-separator-line\"\n      />\n      <div class=\"str-chat__date-separator-date\">\n        {{ parsedDate }}\n      </div>\n      <hr\n        *ngIf=\"\n          dateSeparatorTextPos === 'left' || dateSeparatorTextPos === 'center'\n        \"\n        class=\"str-chat__date-separator-line\"\n      />\n    </div>\n  </ng-template>\n</ng-template>\n\n<ng-template #defaultNewMessagesIndicator let-unreadCount=\"unreadCount\">\n  <div class=\"str-chat__unread-messages-separator\">\n    <ng-container\n      *ngIf=\"\n        unreadCount > 0 && !hideUnreadCountForNotificationAndIndicator;\n        else noUnreadCount\n      \"\n    >\n      {{\n        (unreadCount === 1\n          ? \"streamChat.\\{\\{count\\}\\} unread message\"\n          : \"streamChat.\\{\\{count\\}\\} unread messages\"\n        ) | translate : { count: unreadCount }\n      }}\n    </ng-container>\n    <ng-template #noUnreadCount>\n      {{ \"streamChat.Unread messages\" | translate }}\n    </ng-template>\n  </div>\n</ng-template>\n" }]
        }], ctorParameters: function () { return [{ type: i1.ChannelService }, { type: i2.ChatClientService }, { type: i3.CustomTemplatesService }, { type: i4.DateParserService }, { type: i0.NgZone }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { mode: [{
                type: Input
            }], direction: [{
                type: Input
            }], hideJumpToLatestButtonDuringScroll: [{
                type: Input
            }], displayDateSeparator: [{
                type: Input
            }], displayUnreadSeparator: [{
                type: Input
            }], dateSeparatorTextPos: [{
                type: Input
            }], openMessageListAt: [{
                type: Input
            }], hideUnreadCountForNotificationAndIndicator: [{
                type: Input
            }], displayLoadingIndicator: [{
                type: Input
            }], scrollContainer: [{
                type: ViewChild,
                args: ['scrollContainer']
            }], parentMessageElement: [{
                type: ViewChild,
                args: ['parentMessageElement']
            }], class: [{
                type: HostBinding,
                args: ['class']
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWVzc2FnZS1saXN0LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL3N0cmVhbS1jaGF0LWFuZ3VsYXIvc3JjL2xpYi9tZXNzYWdlLWxpc3QvbWVzc2FnZS1saXN0LmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL3N0cmVhbS1jaGF0LWFuZ3VsYXIvc3JjL2xpYi9tZXNzYWdlLWxpc3QvbWVzc2FnZS1saXN0LmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFHTCx1QkFBdUIsRUFFdkIsU0FBUyxFQUVULFdBQVcsRUFDWCxLQUFLLEVBT0wsU0FBUyxHQUNWLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBRSxlQUFlLEVBQWMsT0FBTyxFQUFnQixNQUFNLE1BQU0sQ0FBQztBQUMxRSxPQUFPLEVBQ0wsTUFBTSxFQUNOLEdBQUcsRUFDSCxXQUFXLEVBQ1gsSUFBSSxFQUNKLEdBQUcsRUFDSCxZQUFZLEdBQ2IsTUFBTSxnQkFBZ0IsQ0FBQztBQVl4QixPQUFPLEVBQUUsY0FBYyxFQUFjLE1BQU0sZ0JBQWdCLENBQUM7QUFHNUQsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUUxQyxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUMxRCxPQUFPLEVBQUUsNkJBQTZCLEVBQUUsTUFBTSxxQ0FBcUMsQ0FBQztBQUNwRixPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sY0FBYyxDQUFDOzs7Ozs7Ozs7Ozs7QUFFeEM7O0dBRUc7QUFPSCxNQUFNLE9BQU8sb0JBQW9CO0lBa0gvQixZQUNVLGNBQThCLEVBQzlCLGlCQUFvQyxFQUNwQyxzQkFBOEMsRUFDOUMsVUFBNkIsRUFDN0IsTUFBYyxFQUNkLEtBQXdCO1FBTHhCLG1CQUFjLEdBQWQsY0FBYyxDQUFnQjtRQUM5QixzQkFBaUIsR0FBakIs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ZCxcbiAgQWZ0ZXJWaWV3SW5pdCxcbiAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gIENoYW5nZURldGVjdG9yUmVmLFxuICBDb21wb25lbnQsXG4gIEVsZW1lbnRSZWYsXG4gIEhvc3RCaW5kaW5nLFxuICBJbnB1dCxcbiAgTmdab25lLFxuICBPbkNoYW5nZXMsXG4gIE9uRGVzdHJveSxcbiAgT25Jbml0LFxuICBTaW1wbGVDaGFuZ2VzLFxuICBUZW1wbGF0ZVJlZixcbiAgVmlld0NoaWxkLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENoYW5uZWxTZXJ2aWNlIH0gZnJvbSAnLi4vY2hhbm5lbC5zZXJ2aWNlJztcbmltcG9ydCB7IEJlaGF2aW9yU3ViamVjdCwgT2JzZXJ2YWJsZSwgU3ViamVjdCwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQge1xuICBmaWx0ZXIsXG4gIG1hcCxcbiAgc2hhcmVSZXBsYXksXG4gIHRha2UsXG4gIHRhcCxcbiAgdGhyb3R0bGVUaW1lLFxufSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQge1xuICBNZXNzYWdlQ29udGV4dCxcbiAgRGVmYXVsdFN0cmVhbUNoYXRHZW5lcmljcyxcbiAgU3RyZWFtTWVzc2FnZSxcbiAgVHlwaW5nSW5kaWNhdG9yQ29udGV4dCxcbiAgRGF0ZVNlcGFyYXRvckNvbnRleHQsXG4gIFVucmVhZE1lc3NhZ2VzTm90aWZpY2F0aW9uQ29udGV4dCxcbiAgVW5yZWFkTWVzc2FnZXNJbmRpY2F0b3JDb250ZXh0LFxuICBWaXJ0dWFsaXplZExpc3RTY3JvbGxQb3NpdGlvbixcbn0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgQ2hhdENsaWVudFNlcnZpY2UgfSBmcm9tICcuLi9jaGF0LWNsaWVudC5zZXJ2aWNlJztcbmltcG9ydCB7IGdldEdyb3VwU3R5bGVzLCBHcm91cFN0eWxlIH0gZnJvbSAnLi9ncm91cC1zdHlsZXMnO1xuaW1wb3J0IHsgTWVzc2FnZVJlc3BvbnNlLCBVc2VyUmVzcG9uc2UgfSBmcm9tICdzdHJlYW0tY2hhdCc7XG5pbXBvcnQgeyBDdXN0b21UZW1wbGF0ZXNTZXJ2aWNlIH0gZnJvbSAnLi4vY3VzdG9tLXRlbXBsYXRlcy5zZXJ2aWNlJztcbmltcG9ydCB7IGxpc3RVc2VycyB9IGZyb20gJy4uL2xpc3QtdXNlcnMnO1xuaW1wb3J0IHsgRGF0ZVBhcnNlclNlcnZpY2UgfSBmcm9tICcuLi9kYXRlLXBhcnNlci5zZXJ2aWNlJztcbmltcG9ydCB7IGlzT25TZXBhcmF0ZURhdGUgfSBmcm9tICcuLi9pcy1vbi1zZXBhcmF0ZS1kYXRlJztcbmltcG9ydCB7IFZpcnR1YWxpemVkTWVzc2FnZUxpc3RTZXJ2aWNlIH0gZnJvbSAnLi4vdmlydHVhbGl6ZWQtbWVzc2FnZS1saXN0LnNlcnZpY2UnO1xuaW1wb3J0IHsgaXNTYWZhcmkgfSBmcm9tICcuLi9pcy1zYWZhcmknO1xuXG4vKipcbiAqIFRoZSBgTWVzc2FnZUxpc3RgIGNvbXBvbmVudCByZW5kZXJzIGEgc2Nyb2xsYWJsZSBsaXN0IG9mIG1lc3NhZ2VzLlxuICovXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICdzdHJlYW0tbWVzc2FnZS1saXN0JyxcbiAgdGVtcGxhdGVVcmw6ICcuL21lc3NhZ2UtbGlzdC5jb21wb25lbnQuaHRtbCcsXG4gIHN0eWxlczogW10sXG4gIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxufSlcbmV4cG9ydCBjbGFzcyBNZXNzYWdlTGlzdENvbXBvbmVudFxuICBpbXBsZW1lbnRzIEFmdGVyVmlld0NoZWNrZWQsIE9uQ2hhbmdlcywgT25Jbml0LCBPbkRlc3Ryb3ksIEFmdGVyVmlld0luaXRcbntcbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgdGhlIG1lc3NhZ2UgbGlzdCBzaG91bGQgZGlzcGxheSBjaGFubmVsIG1lc3NhZ2VzIG9yIFt0aHJlYWQgbWVzc2FnZXNdKC9jaGF0L2RvY3MvamF2YXNjcmlwdC90aHJlYWRzLykuXG4gICAqL1xuICBASW5wdXQoKSBtb2RlOiAnbWFpbicgfCAndGhyZWFkJyA9ICdtYWluJztcbiAgLyoqXG4gICAqIFRoZSBkaXJlY3Rpb24gb2YgdGhlIG1lc3NhZ2VzIGluIHRoZSBsaXN0LCBgYm90dG9tLXRvLXRvcGAgbWVhbnMgbmV3ZXN0IG1lc3NhZ2UgaXMgYXQgdGhlIGJvdHRvbSBvZiB0aGUgbWVzc2FnZSBsaXN0IGFuZCB1c2VycyBzY3JvbGwgdXB3YXJkcyB0byBsb2FkIG9sZGVyIG1lc3NhZ2VzXG4gICAqL1xuICBASW5wdXQoKSBkaXJlY3Rpb246ICdib3R0b20tdG8tdG9wJyB8ICd0b3AtdG8tYm90dG9tJyA9ICdib3R0b20tdG8tdG9wJztcbiAgLyoqXG4gICAqIFlvdSBjYW4gaGlkZSB0aGUgXCJqdW1wIHRvIGxhdGVzdFwiIGJ1dHRvbiB3aGlsZSBzY3JvbGxpbmcuIEEgcG90ZW50aWFsIHVzZS1jYXNlIGZvciB0aGlzIGlucHV0IHdvdWxkIGJlIHRvIFt3b3JrYXJvdW5kIGEga25vd24gaXNzdWUgb24gaU9TIFNhZmFyIHdlYnZpZXddKGh0dHBzOi8vZ2l0aHViLmNvbS9HZXRTdHJlYW0vc3RyZWFtLWNoYXQtYW5ndWxhci9pc3N1ZXMvNDE4KVxuICAgKlxuICAgKi9cbiAgQElucHV0KCkgaGlkZUp1bXBUb0xhdGVzdEJ1dHRvbkR1cmluZ1Njcm9sbCA9IGZhbHNlO1xuICAvKipcbiAgICogSWYgYHRydWVgIGRhdGUgc2VwYXJhdG9ycyB3aWxsIGJlIGRpc3BsYXllZFxuICAgKi9cbiAgQElucHV0KCkgZGlzcGxheURhdGVTZXBhcmF0b3IgPSB0cnVlO1xuICAvKipcbiAgICogSWYgYHRydWVgIHVucmVhZCBpbmRpY2F0b3Igd2lsbCBiZSBkaXNwbGF5ZWRcbiAgICovXG4gIEBJbnB1dCgpIGRpc3BsYXlVbnJlYWRTZXBhcmF0b3IgPSB0cnVlO1xuICAvKipcbiAgICogSWYgZGF0ZSBzZXBhcmF0b3JzIGFyZSBkaXNwbGF5ZWQsIHlvdSBjYW4gc2V0IHRoZSBob3Jpem9udGFsIHBvc2l0aW9uIG9mIHRoZSBkYXRlIHRleHQuXG4gICAqL1xuICBASW5wdXQoKSBkYXRlU2VwYXJhdG9yVGV4dFBvczogJ2NlbnRlcicgfCAncmlnaHQnIHwgJ2xlZnQnID0gJ2NlbnRlcic7XG4gIC8qKlxuICAgKiBgbGFzdC1tZXNzYWdlYCBvcHRpb24gd2lsbCBvcGVuIHRoZSBtZXNzYWdlIGxpc3QgYXQgdGhlIGxhc3QgbWVzc2FnZSwgYGxhc3QtcmVhZC1tZXNzYWdlYCB3aWxsIG9wZW4gdGhlIGxpc3QgYXQgdGhlIGxhc3QgdW5yZWFkIG1lc3NhZ2UuIFRoaXMgb3B0aW9uIG9ubHkgd29ya3MgaWYgbW9kZSBpcyBgbWFpbmAuXG4gICAqL1xuICBASW5wdXQoKSBvcGVuTWVzc2FnZUxpc3RBdDogJ2xhc3QtbWVzc2FnZScgfCAnbGFzdC1yZWFkLW1lc3NhZ2UnID1cbiAgICAnbGFzdC1tZXNzYWdlJztcbiAgLyoqXG4gICAqIElmIHRoZSB1c2VyIGhhcyB1bnJlYWQgbWVzc2FnZXMgd2hlbiB0aGV5IG9wZW4gdGhlIGNoYW5uZWwgdGhlIFVJIHNob3dzIHRoZSB1bnJlYWQgaW5kaWNhdG9yIC8gbm90aWZpY2F0aW9uIHdoaWNoIGZlYXR1cmVzIHRoZSB1bnJlYWQgY291bnQgYnkgZGVmYXVsdC4gVGhpcyBjb3VudCB3aWxsIGJlIGluY3JlYXNlZCBldmVyeSB0aW1lIGEgdXNlciByZWNlaXZlcyBhIG5ldyBtZXNzYWdlLiBJZiB5b3UgZG9uJ3Qgd2FudCB0byBzaG93IHRoZSB1bnJlYWQgY291bnQsIHlvdSBjYW4gdHVybiB0aGF0IG9mZi5cbiAgICpcbiAgICogVGhpcyBpcyBvbmx5IGFwcGxpY2FibGUgZm9yIGBtYWluYCBtb2RlLCBhcyB0aHJlYWRzIGRvZXNuJ3QgaGF2ZSByZWFkIGluZnJvbWF0aW9uLlxuICAgKi9cbiAgQElucHV0KCkgaGlkZVVucmVhZENvdW50Rm9yTm90aWZpY2F0aW9uQW5kSW5kaWNhdG9yID0gZmFsc2U7XG4gIC8qKlxuICAgKiBZb3UgY2FuIHR1cm4gb24gYW5kIG9mZiB0aGUgbG9hZGluZyBpbmRpY2F0b3IgdGhhdCBzaWduYWxzIHRvIHVzZXJzIHRoYXQgbW9yZSBtZXNzYWdlcyBhcmUgYmVpbmcgbG9hZGVkIHRvIHRoZSBtZXNzYWdlIGxpc3RcbiAgICovXG4gIEBJbnB1dCgpIGRpc3BsYXlMb2FkaW5nSW5kaWNhdG9yID0gdHJ1ZTtcbiAgdHlwaW5nSW5kaWNhdG9yVGVtcGxhdGU6IFRlbXBsYXRlUmVmPFR5cGluZ0luZGljYXRvckNvbnRleHQ+IHwgdW5kZWZpbmVkO1xuICBtZXNzYWdlVGVtcGxhdGU6IFRlbXBsYXRlUmVmPE1lc3NhZ2VDb250ZXh0PiB8IHVuZGVmaW5lZDtcbiAgY3VzdG9tRGF0ZVNlcGFyYXRvclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxEYXRlU2VwYXJhdG9yQ29udGV4dD4gfCB1bmRlZmluZWQ7XG4gIGN1c3RvbW5ld01lc3NhZ2VzSW5kaWNhdG9yVGVtcGxhdGU6XG4gICAgfCBUZW1wbGF0ZVJlZjxVbnJlYWRNZXNzYWdlc0luZGljYXRvckNvbnRleHQ+XG4gICAgfCB1bmRlZmluZWQ7XG4gIGN1c3RvbW5ld01lc3NhZ2VzTm90aWZpY2F0aW9uVGVtcGxhdGU6XG4gICAgfCBUZW1wbGF0ZVJlZjxVbnJlYWRNZXNzYWdlc05vdGlmaWNhdGlvbkNvbnRleHQ+XG4gICAgfCB1bmRlZmluZWQ7XG4gIGVtcHR5TWFpbk1lc3NhZ2VMaXN0VGVtcGxhdGU6IFRlbXBsYXRlUmVmPHZvaWQ+IHwgbnVsbCA9IG51bGw7XG4gIGVtcHR5VGhyZWFkTWVzc2FnZUxpc3RUZW1wbGF0ZTogVGVtcGxhdGVSZWY8dm9pZD4gfCBudWxsID0gbnVsbDtcbiAgbWVzc2FnZXMkITogT2JzZXJ2YWJsZTxTdHJlYW1NZXNzYWdlW10+O1xuICBlbmFibGVkTWVzc2FnZUFjdGlvbnM6IHN0cmluZ1tdID0gW107XG4gIGlzRW1wdHkgPSB0cnVlO1xuICBuZXdNZXNzYWdlQ291bnRXaGlsZUJlaW5nU2Nyb2xsZWQgPSAwO1xuICBpc1VzZXJTY3JvbGxlZDogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbiAgZ3JvdXBTdHlsZXM6IEdyb3VwU3R5bGVbXSA9IFtdO1xuICBpc05leHRNZXNzYWdlT25TZXBhcmF0ZURhdGU6IGJvb2xlYW5bXSA9IFtdO1xuICBsYXN0U2VudE1lc3NhZ2VJZDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBwYXJlbnRNZXNzYWdlOiBTdHJlYW1NZXNzYWdlIHwgdW5kZWZpbmVkO1xuICBoaWdobGlnaHRlZE1lc3NhZ2VJZDogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBsb2FkaW5nU3RhdGU6ICdpZGxlJyB8ICdsb2FkaW5nLXRvcCcgfCAnbG9hZGluZy1ib3R0b20nID0gJ2lkbGUnO1xuICBzY3JvbGxFbmRUaW1lb3V0PzogUmV0dXJuVHlwZTx0eXBlb2Ygc2V0VGltZW91dD47XG4gIGxhc3RSZWFkTWVzc2FnZUlkPzogc3RyaW5nO1xuICBpc1VucmVhZE5vdGlmaWNhdGlvblZpc2libGUgPSB0cnVlO1xuICBmaXJzdFVucmVhZE1lc3NhZ2VJZD86IHN0cmluZztcbiAgdW5yZWFkQ291bnQ/OiBudW1iZXI7XG4gIGlzSnVtcGluZ1RvTGF0ZXN0VW5yZWFkTWVzc2FnZSA9IGZhbHNlO1xuICBpc0p1bXBUb0xhdGVzdEJ1dHRvblZpc2libGUgPSB0cnVlO1xuICBpc0p1bXBpbmdUb01lc3NhZ2UgPSBmYWxzZTtcbiAgc2Nyb2xsJCA9IG5ldyBTdWJqZWN0PHZvaWQ+KCk7XG4gIEBWaWV3Q2hpbGQoJ3Njcm9sbENvbnRhaW5lcicpXG4gIHByaXZhdGUgc2Nyb2xsQ29udGFpbmVyITogRWxlbWVudFJlZjxIVE1MRWxlbWVudD47XG4gIEBWaWV3Q2hpbGQoJ3BhcmVudE1lc3NhZ2VFbGVtZW50JylcbiAgcHJpdmF0ZSBwYXJlbnRNZXNzYWdlRWxlbWVudCE6IEVsZW1lbnRSZWY8SFRNTEVsZW1lbnQ+O1xuICBwcml2YXRlIGlzTmV3TWVzc2FnZVNlbnRCeVVzZXI6IGJvb2xlYW4gPSBmYWxzZTtcbiAgcHJpdmF0ZSBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuICBwcml2YXRlIG5ld01lc3NhZ2VTdWJzY3JpcHRpb246IHsgdW5zdWJzY3JpYmU6ICgpID0+IHZvaWQgfSB8IHVuZGVmaW5lZDtcbiAgcHJpdmF0ZSB1c2Vyc1R5cGluZ0luQ2hhbm5lbCQhOiBPYnNlcnZhYmxlPFxuICAgIFVzZXJSZXNwb25zZTxEZWZhdWx0U3RyZWFtQ2hhdEdlbmVyaWNzPltdXG4gID47XG4gIHByaXZhdGUgdXNlcnNUeXBpbmdJblRocmVhZCQhOiBPYnNlcnZhYmxlPFxuICAgIFVzZXJSZXNwb25zZTxEZWZhdWx0U3RyZWFtQ2hhdEdlbmVyaWNzPltdXG4gID47XG4gIHByaXZhdGUgaXNMYXRlc3RNZXNzYWdlSW5MaXN0ID0gdHJ1ZTtcbiAgcHJpdmF0ZSBjaGFubmVsSWQ/OiBzdHJpbmc7XG4gIHByaXZhdGUgcGFyc2VkRGF0ZXMgPSBuZXcgTWFwPERhdGUsIHN0cmluZz4oKTtcbiAgcHJpdmF0ZSBpc1ZpZXdJbml0ZWQgPSBmYWxzZTtcbiAgcHJpdmF0ZSBjaGVja0lmVW5yZWFkTm90aWZpY2F0aW9uSXNWaXNpYmxlVGltZW91dD86IFJldHVyblR5cGU8XG4gICAgdHlwZW9mIHNldFRpbWVvdXRcbiAgPjtcbiAgcHJpdmF0ZSBqdW1wVG9NZXNzYWdlVGltZW91dHM6IFJldHVyblR5cGU8dHlwZW9mIHNldFRpbWVvdXQ+W10gPSBbXTtcbiAgcHJpdmF0ZSBqdW1wVG9MYXRlc3RCdXR0b25WaXNpYmlsaXR5VGltZW91dD86IFJldHVyblR5cGU8dHlwZW9mIHNldFRpbWVvdXQ+O1xuICBwcml2YXRlIGZvcmNlUmVwYWludFN1YmplY3QgPSBuZXcgU3ViamVjdDx2b2lkPigpO1xuICBwcml2YXRlIG1lc3NhZ2VJZFRvQW5jaG9yVG8/OiBzdHJpbmc7XG4gIHByaXZhdGUgYW5jaG9yTWVzc2FnZVRvcE9mZnNldD86IG51bWJlcjtcbiAgcHJpdmF0ZSBpc1NhZmFyaSA9IGlzU2FmYXJpKCk7XG5cbiAgQEhvc3RCaW5kaW5nKCdjbGFzcycpXG4gIHByaXZhdGUgZ2V0IGNsYXNzKCkge1xuICAgIHJldHVybiBgc3RyLWNoYXQtYW5ndWxhcl9fbWFpbi1wYW5lbC1pbm5lciBzdHItY2hhdC1hbmd1bGFyX19tZXNzYWdlLWxpc3QtaG9zdCBzdHItY2hhdF9fbWFpbi1wYW5lbC1pbm5lciAke1xuICAgICAgdGhpcy5pc0VtcHR5ID8gJ3N0ci1jaGF0LWFuZ3VsYXJfX21lc3NhZ2UtbGlzdC1ob3N0LS1lbXB0eScgOiAnJ1xuICAgIH1gO1xuICB9XG4gIHByaXZhdGUgdmlydHVhbGl6ZWRMaXN0PzogVmlydHVhbGl6ZWRNZXNzYWdlTGlzdFNlcnZpY2U7XG4gIHByaXZhdGUgc2Nyb2xsUG9zaXRpb24kID0gbmV3IEJlaGF2aW9yU3ViamVjdDxWaXJ0dWFsaXplZExpc3RTY3JvbGxQb3NpdGlvbj4oXG4gICAgJ2JvdHRvbSdcbiAgKTtcbiAgcHJpdmF0ZSBqdW1wVG9JdGVtU3Vic2NyaXB0aW9uPzogU3Vic2NyaXB0aW9uO1xuICBwcml2YXRlIHF1ZXJ5U3RhdGVTdWJzY3JpcHRpb24/OiBTdWJzY3JpcHRpb247XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBjaGFubmVsU2VydmljZTogQ2hhbm5lbFNlcnZpY2UsXG4gICAgcHJpdmF0ZSBjaGF0Q2xpZW50U2VydmljZTogQ2hhdENsaWVudFNlcnZpY2UsXG4gICAgcHJpdmF0ZSBjdXN0b21UZW1wbGF0ZXNTZXJ2aWNlOiBDdXN0b21UZW1wbGF0ZXNTZXJ2aWNlLFxuICAgIHByaXZhdGUgZGF0ZVBhcnNlcjogRGF0ZVBhcnNlclNlcnZpY2UsXG4gICAgcHJpdmF0ZSBuZ1pvbmU6IE5nWm9uZSxcbiAgICBwcml2YXRlIGNkUmVmOiBDaGFuZ2VEZXRlY3RvclJlZlxuICApIHtcbiAgICB0aGlzLnVzZXJzVHlwaW5nSW5DaGFubmVsJCA9IHRoaXMuY2hhbm5lbFNlcnZpY2UudXNlcnNUeXBpbmdJbkNoYW5uZWwkO1xuICAgIHRoaXMudXNlcnNUeXBpbmdJblRocmVhZCQgPSB0aGlzLmNoYW5uZWxTZXJ2aWNlLnVzZXJzVHlwaW5nSW5UaHJlYWQkO1xuICB9XG5cbiAgbWVzc2FnZU5vdGlmaWNhdGlvbkp1bXBDbGlja2VkID0gKCkgPT4ge1xuICAgIHRoaXMuanVtcFRvRmlyc3RVbnJlYWRNZXNzYWdlKCk7XG4gICAgdGhpcy5pc1VucmVhZE5vdGlmaWNhdGlvblZpc2libGUgPSBmYWxzZTtcbiAgfTtcblxuICBtZXNzYWdlTm90aWZpY2F0aW9uRGlzbWlzc0NsaWNrZWQgPSAoKSA9PiB7XG4gICAgdGhpcy5pc1VucmVhZE5vdGlmaWNhdGlvblZpc2libGUgPSBmYWxzZTtcbiAgfTtcblxuICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuZm9yY2VSZXBhaW50U3ViamVjdC5waXBlKHRocm90dGxlVGltZSgxMDAwKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgdGhpcy5mb3JjZVJlcGFpbnQoKTtcbiAgICAgIH0pXG4gICAgKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuY2hhbm5lbFNlcnZpY2UuYWN0aXZlQ2hhbm5lbCQuc3Vic2NyaWJlKChjaGFubmVsKSA9PiB7XG4gICAgICAgIGxldCB3YXNDaGFubmVsU3dpdGNoID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWxJZCAhPT0gY2hhbm5lbD8uaWQpIHtcbiAgICAgICAgICB3YXNDaGFubmVsU3dpdGNoID0gdHJ1ZTtcbiAgICAgICAgICBpZiAodGhpcy5jaGVja0lmVW5yZWFkTm90aWZpY2F0aW9uSXNWaXNpYmxlVGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY2hlY2tJZlVucmVhZE5vdGlmaWNhdGlvbklzVmlzaWJsZVRpbWVvdXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmp1bXBUb01lc3NhZ2VUaW1lb3V0cy5mb3JFYWNoKCh0aW1lb3V0KSA9PlxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpXG4gICAgICAgICAgKTtcbiAgICAgICAgICB0aGlzLmp1bXBUb01lc3NhZ2VUaW1lb3V0cyA9IFtdO1xuICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWRNZXNzYWdlSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgdGhpcy5pc1VucmVhZE5vdGlmaWNhdGlvblZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLnBhcnNlZERhdGVzID0gbmV3IE1hcCgpO1xuICAgICAgICAgIHRoaXMucmVzZXRTY3JvbGxTdGF0ZSgpO1xuICAgICAgICAgIHRoaXMuc2V0TWVzc2FnZXMkKCk7XG4gICAgICAgICAgdGhpcy5jaGFubmVsSWQgPSBjaGFubmVsPy5pZDtcbiAgICAgICAgICBpZiAodGhpcy5pc1ZpZXdJbml0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2RSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tb2RlID09PSAnbWFpbicpIHtcbiAgICAgICAgICBjb25zdCBsYXN0UmVhZE1lc3NhZ2VJZCA9XG4gICAgICAgICAgICB0aGlzLmNoYW5uZWxTZXJ2aWNlLmFjdGl2ZUNoYW5uZWxMYXN0UmVhZE1lc3NhZ2VJZDtcbiAgICAgICAgICBjb25zdCB1bnJlYWRDb3VudCA9IHRoaXMuY2hhbm5lbFNlcnZpY2UuYWN0aXZlQ2hhbm5lbFVucmVhZENvdW50O1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIGxhc3RSZWFkTWVzc2FnZUlkICE9PSB0aGlzLmxhc3RSZWFkTWVzc2FnZUlkIHx8XG4gICAgICAgICAgICB1bnJlYWRDb3VudCAhPT0gdGhpcy51bnJlYWRDb3VudFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5sYXN0UmVhZE1lc3NhZ2VJZCA9IGxhc3RSZWFkTWVzc2FnZUlkO1xuICAgICAgICAgICAgdGhpcy51bnJlYWRDb3VudCA9IHVucmVhZENvdW50IHx8IDA7XG4gICAgICAgICAgICBpZiAod2FzQ2hhbm5lbFN3aXRjaCAmJiB0aGlzLmxhc3RSZWFkTWVzc2FnZUlkKSB7XG4gICAgICAgICAgICAgIC8vIERlbGF5IGp1bXBpbmcgdG8gbGFzdCByZWFkIG1lc3NhZ2UgaW4gY2FzZSB3ZSBuZWVkIHRvIGdpdmUgcHJlY2VkZW5jZSB0byBjaGFubmVsU2VydmljZS5qdW1wVG9NZXNzYWdlXG4gICAgICAgICAgICAgIGlmICh0aGlzLm9wZW5NZXNzYWdlTGlzdEF0ID09PSAnbGFzdC1yZWFkLW1lc3NhZ2UnKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAvLyBEb24ndCBqdW1wIGlmIGEganVtcCB0byBhIG1lc3NhZ2Ugd2FzIGFscmVhZHkgc3RhcnRlZCAodXNpbmcgY2hhbm5lbFNlcnZpY2UuanVtcFRvTWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgIXRoaXMuaXNKdW1waW5nVG9NZXNzYWdlICYmXG4gICAgICAgICAgICAgICAgICAgICF0aGlzLmNoYW5uZWxTZXJ2aWNlLmlzTWVzc2FnZUxvYWRpbmdJblByb2dyZXNzXG4gICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5qdW1wVG9GaXJzdFVucmVhZE1lc3NhZ2UoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBXYWl0IHRpbGwgbWVzc2FnZXMgYW5kIHRoZSB1bnJlYWQgYmFubmVyIGlzIHJlbmRlcmVkXG4gICAgICAgICAgICAgICAgLy8gSWYgdW5yZWFkIGJhbm5lciBpc24ndCB2aXNpYmxlIG9uIHRoZSBzY3JlZW4sIHdlIGRpc3BsYXkgdGhlIHVucmVhZCBub3RpZmljYWlvblxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgY29uc3QgYmFubmVyRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFxuICAgICAgICAgICAgICAgICAgICAnc3RyZWFtLWNoYXQtbmV3LW1lc3NhZ2UtaW5kaWNhdG9yJ1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgIWJhbm5lckVsZW1lbnQgfHxcbiAgICAgICAgICAgICAgICAgICAgYmFubmVyRWxlbWVudD8ub2Zmc2V0VG9wIDxcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbENvbnRhaW5lcj8ubmF0aXZlRWxlbWVudD8uc2Nyb2xsSGVpZ2h0IC1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsQ29udGFpbmVyPy5uYXRpdmVFbGVtZW50Py5jbGllbnRIZWlnaHRcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzVW5yZWFkTm90aWZpY2F0aW9uVmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzVmlld0luaXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2RSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaXNWaWV3SW5pdGVkKSB7XG4gICAgICAgICAgICAgIHRoaXMuY2RSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmxhc3RSZWFkTWVzc2FnZUlkKSB7XG4gICAgICAgICAgdGhpcy5sYXN0UmVhZE1lc3NhZ2VJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB0aGlzLnVucmVhZENvdW50ID0gMDtcbiAgICAgICAgICBpZiAodGhpcy5pc1ZpZXdJbml0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2RSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYXBhYmlsaXRlcyA9IGNoYW5uZWw/LmRhdGE/Lm93bl9jYXBhYmlsaXRpZXMgYXMgc3RyaW5nW107XG4gICAgICAgIGNvbnN0IGNhcGFiaWxpdGVzU3RyaW5nID0gWy4uLihjYXBhYmlsaXRlcyB8fCBbXSldLnNvcnQoKS5qb2luKCcnKTtcbiAgICAgICAgY29uc3QgZW5hYmxlZEFjdGlvbnNTdHJpbmcgPSBbLi4uKHRoaXMuZW5hYmxlZE1lc3NhZ2VBY3Rpb25zIHx8IFtdKV1cbiAgICAgICAgICAuc29ydCgpXG4gICAgICAgICAgLmpvaW4oJycpO1xuICAgICAgICBpZiAoY2FwYWJpbGl0ZXNTdHJpbmcgIT09IGVuYWJsZWRBY3Rpb25zU3RyaW5nKSB7XG4gICAgICAgICAgdGhpcy5lbmFibGVkTWVzc2FnZUFjdGlvbnMgPSBjYXBhYmlsaXRlcyB8fCBbXTtcbiAgICAgICAgICBpZiAodGhpcy5pc1ZpZXdJbml0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2RSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5ld01lc3NhZ2VTdWJzY3JpcHRpb24/LnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIGlmIChjaGFubmVsKSB7XG4gICAgICAgICAgdGhpcy5uZXdNZXNzYWdlU3Vic2NyaXB0aW9uID0gY2hhbm5lbC5vbignbWVzc2FnZS5uZXcnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICghZXZlbnQubWVzc2FnZSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLm5ld01lc3NhZ2VSZWNlaXZlZChldmVudC5tZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5jaGFubmVsU2VydmljZS5hY3RpdmVQYXJlbnRNZXNzYWdlJC5zdWJzY3JpYmUoKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgaWYgKCFtZXNzYWdlICYmIHRoaXMucGFyZW50TWVzc2FnZSAmJiB0aGlzLm1vZGUgPT09ICd0aHJlYWQnKSB7XG4gICAgICAgICAgdGhpcy5yZXNldFNjcm9sbFN0YXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgIG1lc3NhZ2UgJiZcbiAgICAgICAgICB0aGlzLnBhcmVudE1lc3NhZ2UgJiZcbiAgICAgICAgICBtZXNzYWdlLmlkICE9PSB0aGlzLnBhcmVudE1lc3NhZ2UuaWQgJiZcbiAgICAgICAgICB0aGlzLm1vZGUgPT09ICd0aHJlYWQnXG4gICAgICAgICkge1xuICAgICAgICAgIHRoaXMucmVzZXRTY3JvbGxTdGF0ZSgpO1xuICAgICAgICAgIHRoaXMuc2V0TWVzc2FnZXMkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFyZW50TWVzc2FnZSA9PT0gbWVzc2FnZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBhcmVudE1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICBpZiAodGhpcy5pc1ZpZXdJbml0ZWQpIHtcbiAgICAgICAgICB0aGlzLmNkUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5jdXN0b21UZW1wbGF0ZXNTZXJ2aWNlLm1lc3NhZ2VUZW1wbGF0ZSQuc3Vic2NyaWJlKCh0ZW1wbGF0ZSkgPT4ge1xuICAgICAgICBpZiAodGhpcy5tZXNzYWdlVGVtcGxhdGUgPT09IHRlbXBsYXRlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVzc2FnZVRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgIGlmICh0aGlzLmlzVmlld0luaXRlZCkge1xuICAgICAgICAgIHRoaXMuY2RSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmN1c3RvbVRlbXBsYXRlc1NlcnZpY2UuZGF0ZVNlcGFyYXRvclRlbXBsYXRlJC5zdWJzY3JpYmUoXG4gICAgICAgICh0ZW1wbGF0ZSkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmN1c3RvbURhdGVTZXBhcmF0b3JUZW1wbGF0ZSA9PT0gdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5jdXN0b21EYXRlU2VwYXJhdG9yVGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICAgICAgICBpZiAodGhpcy5pc1ZpZXdJbml0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2RSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKVxuICAgICk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmN1c3RvbVRlbXBsYXRlc1NlcnZpY2UubmV3TWVzc2FnZXNJbmRpY2F0b3JUZW1wbGF0ZSQuc3Vic2NyaWJlKFxuICAgICAgICAodGVtcGxhdGUpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5jdXN0b21uZXdNZXNzYWdlc0luZGljYXRvclRlbXBsYXRlID09PSB0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmN1c3RvbW5ld01lc3NhZ2VzSW5kaWNhdG9yVGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICAgICAgICBpZiAodGhpcy5pc1ZpZXdJbml0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2RSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKVxuICAgICk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmN1c3RvbVRlbXBsYXRlc1NlcnZpY2UubmV3TWVzc2FnZXNOb3RpZmljYXRpb25UZW1wbGF0ZSQuc3Vic2NyaWJlKFxuICAgICAgICAodGVtcGxhdGUpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5jdXN0b21uZXdNZXNzYWdlc05vdGlmaWNhdGlvblRlbXBsYXRlID09PSB0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmN1c3RvbW5ld01lc3NhZ2VzTm90aWZpY2F0aW9uVGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICAgICAgICBpZiAodGhpcy5pc1ZpZXdJbml0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2RSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKVxuICAgICk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmN1c3RvbVRlbXBsYXRlc1NlcnZpY2UudHlwaW5nSW5kaWNhdG9yVGVtcGxhdGUkLnN1YnNjcmliZShcbiAgICAgICAgKHRlbXBsYXRlKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMudHlwaW5nSW5kaWNhdG9yVGVtcGxhdGUgPT09IHRlbXBsYXRlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudHlwaW5nSW5kaWNhdG9yVGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICAgICAgICBpZiAodGhpcy5pc1ZpZXdJbml0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2RSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgKVxuICAgICk7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLmN1c3RvbVRlbXBsYXRlc1NlcnZpY2UuZW1wdHlNYWluTWVzc2FnZUxpc3RQbGFjZWhvbGRlciQuc3Vic2NyaWJlKFxuICAgICAgICAodGVtcGxhdGUpID0+IHtcbiAgICAgICAgICBjb25zdCBpc0NoYW5nZWQgPSB0aGlzLmVtcHR5TWFpbk1lc3NhZ2VMaXN0VGVtcGxhdGUgIT09IHRlbXBsYXRlO1xuICAgICAgICAgIHRoaXMuZW1wdHlNYWluTWVzc2FnZUxpc3RUZW1wbGF0ZSA9IHRlbXBsYXRlIHx8IG51bGw7XG4gICAgICAgICAgaWYgKGlzQ2hhbmdlZCAmJiB0aGlzLmlzVmlld0luaXRlZCkge1xuICAgICAgICAgICAgdGhpcy5jZFJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApXG4gICAgKTtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMuY3VzdG9tVGVtcGxhdGVzU2VydmljZS5lbXB0eVRocmVhZE1lc3NhZ2VMaXN0UGxhY2Vob2xkZXIkLnN1YnNjcmliZShcbiAgICAgICAgKHRlbXBsYXRlKSA9PiB7XG4gICAgICAgICAgY29uc3QgaXNDaGFuZ2VkID0gdGhpcy5lbXB0eVRocmVhZE1lc3NhZ2VMaXN0VGVtcGxhdGUgIT09IHRlbXBsYXRlO1xuICAgICAgICAgIHRoaXMuZW1wdHlUaHJlYWRNZXNzYWdlTGlzdFRlbXBsYXRlID0gdGVtcGxhdGUgfHwgbnVsbDtcbiAgICAgICAgICBpZiAoaXNDaGFuZ2VkICYmIHRoaXMuaXNWaWV3SW5pdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNkUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIClcbiAgICApO1xuICAgIHRoaXMuc2V0TWVzc2FnZXMkKCk7XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgaWYgKGNoYW5nZXMubW9kZSB8fCBjaGFuZ2VzLmRpcmVjdGlvbikge1xuICAgICAgdGhpcy5yZXNldFNjcm9sbFN0YXRlKCk7XG4gICAgICB0aGlzLnNldE1lc3NhZ2VzJCgpO1xuICAgIH1cbiAgICBpZiAoY2hhbmdlcy5kaXJlY3Rpb24pIHtcbiAgICAgIGlmICh0aGlzLnNjcm9sbENvbnRhaW5lcj8ubmF0aXZlRWxlbWVudCkge1xuICAgICAgICB0aGlzLmp1bXBUb0xhdGVzdE1lc3NhZ2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgdGhpcy5pc1ZpZXdJbml0ZWQgPSB0cnVlO1xuICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgIHRoaXMuc2Nyb2xsQ29udGFpbmVyPy5uYXRpdmVFbGVtZW50Py5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCAoKSA9PlxuICAgICAgICB0aGlzLnNjcm9sbGVkKClcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cblxuICBuZ0FmdGVyVmlld0NoZWNrZWQoKSB7XG4gICAgaWYgKHRoaXMuaXNKdW1waW5nVG9NZXNzYWdlKSB7XG4gICAgICB0aGlzLmlzTmV3TWVzc2FnZVNlbnRCeVVzZXIgPSBmYWxzZTtcbiAgICAgIHRoaXMubWVzc2FnZUlkVG9BbmNob3JUbyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuYW5jaG9yTWVzc2FnZVRvcE9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubWVzc2FnZUlkVG9BbmNob3JUbyAmJiB0aGlzLmxvYWRpbmdTdGF0ZSA9PT0gJ2lkbGUnKSB7XG4gICAgICB0aGlzLnByZXNlcnZlU2Nyb2xsYmFyUG9zaXRpb24oKTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgKCF0aGlzLmlzVXNlclNjcm9sbGVkICYmXG4gICAgICAgIHRoaXMuc2Nyb2xsQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQ/LnNjcm9sbEhlaWdodCA+XG4gICAgICAgICAgdGhpcy5zY3JvbGxDb250YWluZXI/Lm5hdGl2ZUVsZW1lbnQuY2xpZW50SGVpZ2h0ICYmXG4gICAgICAgIHRoaXMuZ2V0U2Nyb2xsUG9zaXRpb24oKSAhPT1cbiAgICAgICAgICAodGhpcy5kaXJlY3Rpb24gPT09ICdib3R0b20tdG8tdG9wJyA/ICdib3R0b20nIDogJ3RvcCcpKSB8fFxuICAgICAgKHRoaXMuaXNVc2VyU2Nyb2xsZWQgJiYgdGhpcy5pc05ld01lc3NhZ2VTZW50QnlVc2VyKVxuICAgICkge1xuICAgICAgdGhpcy5pc05ld01lc3NhZ2VTZW50QnlVc2VyID0gZmFsc2U7XG4gICAgICB0aGlzLmp1bXBUb0xhdGVzdE1lc3NhZ2UoKTtcbiAgICB9XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaCgocykgPT4gcy51bnN1YnNjcmliZSgpKTtcbiAgICB0aGlzLm5ld01lc3NhZ2VTdWJzY3JpcHRpb24/LnVuc3Vic2NyaWJlKCk7XG4gICAgaWYgKHRoaXMuc2Nyb2xsRW5kVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuc2Nyb2xsRW5kVGltZW91dCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNoZWNrSWZVbnJlYWROb3RpZmljYXRpb25Jc1Zpc2libGVUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5jaGVja0lmVW5yZWFkTm90aWZpY2F0aW9uSXNWaXNpYmxlVGltZW91dCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmp1bXBUb0xhdGVzdEJ1dHRvblZpc2liaWxpdHlUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5qdW1wVG9MYXRlc3RCdXR0b25WaXNpYmlsaXR5VGltZW91dCk7XG4gICAgfVxuICAgIHRoaXMuanVtcFRvTWVzc2FnZVRpbWVvdXRzLmZvckVhY2goKHRpbWVvdXQpID0+IGNsZWFyVGltZW91dCh0aW1lb3V0KSk7XG4gICAgdGhpcy5kaXNwb3NlVmlydHVhbGl6ZWRMaXN0KCk7XG4gIH1cblxuICB0cmFja0J5TWVzc2FnZUlkKF86IG51bWJlciwgaXRlbTogU3RyZWFtTWVzc2FnZSkge1xuICAgIHJldHVybiBpdGVtLmlkO1xuICB9XG5cbiAgdHJhY2tCeVVzZXJJZChfOiBudW1iZXIsIHVzZXI6IFVzZXJSZXNwb25zZSkge1xuICAgIHJldHVybiB1c2VyLmlkO1xuICB9XG5cbiAganVtcFRvTGF0ZXN0TWVzc2FnZSgpIHtcbiAgICBpZiAodGhpcy5pc0xhdGVzdE1lc3NhZ2VJbkxpc3QpIHtcbiAgICAgIHRoaXMuZGlyZWN0aW9uID09PSAnYm90dG9tLXRvLXRvcCdcbiAgICAgICAgPyB0aGlzLnNjcm9sbFRvQm90dG9tKClcbiAgICAgICAgOiB0aGlzLnNjcm9sbFRvVG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZvaWQgdGhpcy5jaGFubmVsU2VydmljZS5qdW1wVG9NZXNzYWdlKFxuICAgICAgICAnbGF0ZXN0JyxcbiAgICAgICAgdGhpcy5tb2RlID09PSAndGhyZWFkJyA/IHRoaXMucGFyZW50TWVzc2FnZT8uaWQgOiB1bmRlZmluZWRcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgc2Nyb2xsVG9Cb3R0b20oKTogdm9pZCB7XG4gICAgdGhpcy5zY3JvbGxDb250YWluZXIubmF0aXZlRWxlbWVudC5zY3JvbGxUb3AgPVxuICAgICAgdGhpcy5zY3JvbGxDb250YWluZXIubmF0aXZlRWxlbWVudC5zY3JvbGxIZWlnaHQgKyAwLjE7XG4gICAgaWYgKHRoaXMuaXNTYWZhcmkpIHtcbiAgICAgIHRoaXMuZm9yY2VSZXBhaW50U3ViamVjdC5uZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgc2Nyb2xsVG9Ub3AoKSB7XG4gICAgdGhpcy5zY3JvbGxDb250YWluZXIubmF0aXZlRWxlbWVudC5zY3JvbGxUb3AgPSAwO1xuICB9XG5cbiAgc2Nyb2xsZWQoKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5zY3JvbGxDb250YWluZXIubmF0aXZlRWxlbWVudC5zY3JvbGxIZWlnaHQgPT09XG4gICAgICB0aGlzLnNjcm9sbENvbnRhaW5lci5uYXRpdmVFbGVtZW50LmNsaWVudEhlaWdodFxuICAgICkge1xuICAgICAgaWYgKHRoaXMuaXNKdW1wVG9MYXRlc3RCdXR0b25WaXNpYmxlKSB7XG4gICAgICAgIHRoaXMuaXNKdW1wVG9MYXRlc3RCdXR0b25WaXNpYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMubmV3TWVzc2FnZUNvdW50V2hpbGVCZWluZ1Njcm9sbGVkID0gMDtcbiAgICAgICAgdGhpcy5jZFJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChcbiAgICAgIHRoaXMuc2Nyb2xsQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQuc2Nyb2xsSGVpZ2h0ID5cbiAgICAgIHRoaXMuc2Nyb2xsQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQuY2xpZW50SGVpZ2h0XG4gICAgKSB7XG4gICAgICBpZiAoIXRoaXMuaXNKdW1wVG9MYXRlc3RCdXR0b25WaXNpYmxlKSB7XG4gICAgICAgIHRoaXMuaXNKdW1wVG9MYXRlc3RCdXR0b25WaXNpYmxlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNjcm9sbCQubmV4dCgpO1xuXG4gICAgdGhpcy5jaGVja0lmVXNlclNjcm9sbGVkKCk7XG5cbiAgICBpZiAodGhpcy5oaWRlSnVtcFRvTGF0ZXN0QnV0dG9uRHVyaW5nU2Nyb2xsKSB7XG4gICAgICBpZiAodGhpcy5pc0p1bXBUb0xhdGVzdEJ1dHRvblZpc2libGUpIHtcbiAgICAgICAgdGhpcy5pc0p1bXBUb0xhdGVzdEJ1dHRvblZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jZFJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5qdW1wVG9MYXRlc3RCdXR0b25WaXNpYmlsaXR5VGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5qdW1wVG9MYXRlc3RCdXR0b25WaXNpYmlsaXR5VGltZW91dCk7XG4gICAgICB9XG4gICAgICB0aGlzLmp1bXBUb0xhdGVzdEJ1dHRvblZpc2liaWxpdHlUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmlzVXNlclNjcm9sbGVkKSB7XG4gICAgICAgICAgdGhpcy5pc0p1bXBUb0xhdGVzdEJ1dHRvblZpc2libGUgPSB0cnVlO1xuICAgICAgICAgIHRoaXMuanVtcFRvTGF0ZXN0QnV0dG9uVmlzaWJpbGl0eVRpbWVvdXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgdGhpcy5jZFJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIDEwMCk7XG4gICAgfVxuICB9XG5cbiAganVtcFRvRmlyc3RVbnJlYWRNZXNzYWdlKCkge1xuICAgIGlmICghdGhpcy5sYXN0UmVhZE1lc3NhZ2VJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzSnVtcGluZ1RvTGF0ZXN0VW5yZWFkTWVzc2FnZSA9IHRydWU7XG4gICAgdm9pZCB0aGlzLmNoYW5uZWxTZXJ2aWNlLmp1bXBUb01lc3NhZ2UodGhpcy5sYXN0UmVhZE1lc3NhZ2VJZCk7XG4gIH1cblxuICBnZXRUeXBpbmdJbmRpY2F0b3JDb250ZXh0KCk6IFR5cGluZ0luZGljYXRvckNvbnRleHQge1xuICAgIHJldHVybiB7XG4gICAgICB1c2Vyc1R5cGluZyQ6IHRoaXMudXNlcnNUeXBpbmckLFxuICAgIH07XG4gIH1cblxuICBnZXRUeXBpbmdJbmRpY2F0b3JUZXh0KHVzZXJzOiBVc2VyUmVzcG9uc2VbXSkge1xuICAgIGNvbnN0IHRleHQgPSBsaXN0VXNlcnModXNlcnMpO1xuXG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cblxuICBpc1NlbnRCeUN1cnJlbnRVc2VyKG1lc3NhZ2U/OiBTdHJlYW1NZXNzYWdlKSB7XG4gICAgaWYgKCFtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlLnVzZXI/LmlkID09PSB0aGlzLmNoYXRDbGllbnRTZXJ2aWNlLmNoYXRDbGllbnQudXNlcj8uaWQ7XG4gIH1cblxuICBwYXJzZURhdGUoZGF0ZTogRGF0ZSkge1xuICAgIGlmICh0aGlzLnBhcnNlZERhdGVzLmhhcyhkYXRlKSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VkRGF0ZXMuZ2V0KGRhdGUpO1xuICAgIH1cbiAgICBjb25zdCBwYXJzZWREYXRlID0gdGhpcy5kYXRlUGFyc2VyLnBhcnNlRGF0ZShkYXRlKTtcbiAgICB0aGlzLnBhcnNlZERhdGVzLnNldChkYXRlLCBwYXJzZWREYXRlKTtcbiAgICByZXR1cm4gcGFyc2VkRGF0ZTtcbiAgfVxuXG4gIGdldCByZXBseUNvdW50UGFyYW0oKSB7XG4gICAgcmV0dXJuIHsgcmVwbHlDb3VudDogdGhpcy5wYXJlbnRNZXNzYWdlPy5yZXBseV9jb3VudCB9O1xuICB9XG5cbiAgZ2V0IGVtcHR5TGlzdFRlbXBsYXRlKCkge1xuICAgIHJldHVybiB0aGlzLm1vZGUgPT09ICdtYWluJ1xuICAgICAgPyB0aGlzLmVtcHR5TWFpbk1lc3NhZ2VMaXN0VGVtcGxhdGVcbiAgICAgIDogdGhpcy5lbXB0eVRocmVhZE1lc3NhZ2VMaXN0VGVtcGxhdGU7XG4gIH1cblxuICBwcml2YXRlIGNoZWNrSWZVc2VyU2Nyb2xsZWQoKSB7XG4gICAgbGV0IHNjcm9sbFBvc2l0aW9uID0gdGhpcy5nZXRTY3JvbGxQb3NpdGlvbigpO1xuXG4gICAgY29uc3QgaXNVc2VyU2Nyb2xsZWQgPVxuICAgICAgKHRoaXMuZGlyZWN0aW9uID09PSAnYm90dG9tLXRvLXRvcCdcbiAgICAgICAgPyBzY3JvbGxQb3NpdGlvbiAhPT0gJ2JvdHRvbSdcbiAgICAgICAgOiBzY3JvbGxQb3NpdGlvbiAhPT0gJ3RvcCcpIHx8ICF0aGlzLmlzTGF0ZXN0TWVzc2FnZUluTGlzdDtcbiAgICBpZiAodGhpcy5pc1VzZXJTY3JvbGxlZCAhPT0gaXNVc2VyU2Nyb2xsZWQpIHtcbiAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgIHRoaXMuaXNVc2VyU2Nyb2xsZWQgPSBpc1VzZXJTY3JvbGxlZDtcbiAgICAgICAgaWYgKCF0aGlzLmlzVXNlclNjcm9sbGVkKSB7XG4gICAgICAgICAgdGhpcy5uZXdNZXNzYWdlQ291bnRXaGlsZUJlaW5nU2Nyb2xsZWQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2RSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJldlNjcm9sbFBvc2l0aW9uID0gdGhpcy5zY3JvbGxQb3NpdGlvbiQuZ2V0VmFsdWUoKTtcblxuICAgIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ3RvcC10by1ib3R0b20nKSB7XG4gICAgICBpZiAoc2Nyb2xsUG9zaXRpb24gPT09ICd0b3AnKSB7XG4gICAgICAgIHNjcm9sbFBvc2l0aW9uID0gJ2JvdHRvbSc7XG4gICAgICB9IGVsc2UgaWYgKHNjcm9sbFBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgICBzY3JvbGxQb3NpdGlvbiA9ICd0b3AnO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2U2Nyb2xsUG9zaXRpb24gIT09IHNjcm9sbFBvc2l0aW9uICYmICF0aGlzLmlzSnVtcGluZ1RvTWVzc2FnZSkge1xuICAgICAgaWYgKHNjcm9sbFBvc2l0aW9uID09PSAndG9wJyB8fCBzY3JvbGxQb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICAgICAgdGhpcy52aXJ0dWFsaXplZExpc3Q/LnZpcnR1YWxpemVkSXRlbXMkXG4gICAgICAgICAgLnBpcGUodGFrZSgxKSlcbiAgICAgICAgICAuc3Vic2NyaWJlKChpdGVtcykgPT4ge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlSWRUb0FuY2hvclRvID1cbiAgICAgICAgICAgICAgc2Nyb2xsUG9zaXRpb24gPT09ICd0b3AnXG4gICAgICAgICAgICAgICAgPyBpdGVtc1swXT8uaWRcbiAgICAgICAgICAgICAgICA6IGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdPy5pZDtcbiAgICAgICAgICAgIHRoaXMuYW5jaG9yTWVzc2FnZVRvcE9mZnNldCA9IGRvY3VtZW50XG4gICAgICAgICAgICAgIC5nZXRFbGVtZW50QnlJZCh0aGlzLm1lc3NhZ2VJZFRvQW5jaG9yVG8pXG4gICAgICAgICAgICAgID8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk/LnRvcDtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMubmdab25lLnJ1bigoKSA9PiB7XG4gICAgICAgIHRoaXMuc2Nyb2xsUG9zaXRpb24kLm5leHQoc2Nyb2xsUG9zaXRpb24pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBwcmVzZXJ2ZVNjcm9sbGJhclBvc2l0aW9uKCkge1xuICAgIGlmICghdGhpcy5tZXNzYWdlSWRUb0FuY2hvclRvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2VUb0FsaWduVG8gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLm1lc3NhZ2VJZFRvQW5jaG9yVG8pO1xuICAgIHRoaXMubWVzc2FnZUlkVG9BbmNob3JUbyA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLnNjcm9sbENvbnRhaW5lci5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCArPVxuICAgICAgKG1lc3NhZ2VUb0FsaWduVG8/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpPy50b3AgfHwgMCkgLVxuICAgICAgKHRoaXMuYW5jaG9yTWVzc2FnZVRvcE9mZnNldCB8fCAwKTtcbiAgICB0aGlzLmFuY2hvck1lc3NhZ2VUb3BPZmZzZXQgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHRoaXMuaXNTYWZhcmkpIHtcbiAgICAgIHRoaXMuZm9yY2VSZXBhaW50U3ViamVjdC5uZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBmb3JjZVJlcGFpbnQoKSB7XG4gICAgLy8gU29sdmVzIHRoZSBpc3N1ZSBvZiBlbXB0eSBzY3JlZW4gb24gU2FmYXJpIHdoZW4gc2Nyb2xsaW5nXG4gICAgdGhpcy5zY3JvbGxDb250YWluZXIubmF0aXZlRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHRoaXMuc2Nyb2xsQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQub2Zmc2V0SGVpZ2h0OyAvLyBubyBuZWVkIHRvIHN0b3JlIHRoaXMgYW55d2hlcmUsIHRoZSByZWZlcmVuY2UgaXMgZW5vdWdoXG4gICAgdGhpcy5zY3JvbGxDb250YWluZXIubmF0aXZlRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gIH1cblxuICBwcml2YXRlIGdldFNjcm9sbFBvc2l0aW9uKCk6ICd0b3AnIHwgJ2JvdHRvbScgfCAnbWlkZGxlJyB7XG4gICAgbGV0IHBvc2l0aW9uOiAndG9wJyB8ICdib3R0b20nIHwgJ21pZGRsZScgPSAnbWlkZGxlJztcbiAgICBpZiAoXG4gICAgICBNYXRoLmNlaWwodGhpcy5zY3JvbGxDb250YWluZXIubmF0aXZlRWxlbWVudC5zY3JvbGxUb3ApICtcbiAgICAgICAgdGhpcy5zY3JvbGxDb250YWluZXIubmF0aXZlRWxlbWVudC5jbGllbnRIZWlnaHQgK1xuICAgICAgICAxID49XG4gICAgICB0aGlzLnNjcm9sbENvbnRhaW5lci5uYXRpdmVFbGVtZW50LnNjcm9sbEhlaWdodFxuICAgICkge1xuICAgICAgcG9zaXRpb24gPSAnYm90dG9tJztcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgTWF0aC5mbG9vcih0aGlzLnNjcm9sbENvbnRhaW5lci5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcCkgPD1cbiAgICAgICh0aGlzLnBhcmVudE1lc3NhZ2VFbGVtZW50Py5uYXRpdmVFbGVtZW50Py5jbGllbnRIZWlnaHQgfHwgMClcbiAgICApIHtcbiAgICAgIHBvc2l0aW9uID0gJ3RvcCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXRNZXNzYWdlcyQoKSB7XG4gICAgdGhpcy5kaXNwb3NlVmlydHVhbGl6ZWRMaXN0KCk7XG4gICAgdGhpcy52aXJ0dWFsaXplZExpc3QgPSBuZXcgVmlydHVhbGl6ZWRNZXNzYWdlTGlzdFNlcnZpY2UoXG4gICAgICB0aGlzLm1vZGUsXG4gICAgICB0aGlzLnNjcm9sbFBvc2l0aW9uJCxcbiAgICAgIHRoaXMuY2hhbm5lbFNlcnZpY2VcbiAgICApO1xuICAgIHRoaXMucXVlcnlTdGF0ZVN1YnNjcmlwdGlvbiA9IHRoaXMudmlydHVhbGl6ZWRMaXN0LnF1ZXJ5U3RhdGUkLnN1YnNjcmliZShcbiAgICAgIChxdWVyeVN0YXRlKSA9PiB7XG4gICAgICAgIGxldCBtYXBwZWRTdGF0ZTogJ2lkbGUnIHwgJ2xvYWRpbmctdG9wJyB8ICdsb2FkaW5nLWJvdHRvbScgPSAnaWRsZSc7XG4gICAgICAgIGlmIChxdWVyeVN0YXRlLnN0YXRlLmluY2x1ZGVzKCdsb2FkaW5nJykpIHtcbiAgICAgICAgICBtYXBwZWRTdGF0ZSA9IChxdWVyeVN0YXRlLnN0YXRlIGFzICdsb2FkaW5nLXRvcCcpIHx8ICdsb2FkaW5nLWJvdHRvbSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcHBlZFN0YXRlICE9PSB0aGlzLmxvYWRpbmdTdGF0ZSkge1xuICAgICAgICAgIHRoaXMubG9hZGluZ1N0YXRlID0gbWFwcGVkU3RhdGU7XG4gICAgICAgICAgaWYgKHRoaXMuaXNWaWV3SW5pdGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNkUmVmLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICAgIHRoaXMubWVzc2FnZXMkID0gdGhpcy52aXJ0dWFsaXplZExpc3QudmlydHVhbGl6ZWRJdGVtcyQucGlwZShcbiAgICAgIHRhcCgoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkpIHtcbiAgICAgICAgICAvLyBjZFJlZi5kZXRlY3RDaGFuZ2VzKCkgaXNuJ3QgZW5vdWdoIGhlcmUsIHRlc3Qgd2lsbCBmYWlsXG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiAodGhpcy5pc0VtcHR5ID0gZmFsc2UpLCAwKTtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICB0YXAoKG1lc3NhZ2VzKSA9PiB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB0aGlzLmlzSnVtcGluZ1RvTGF0ZXN0VW5yZWFkTWVzc2FnZSAmJlxuICAgICAgICAgICF0aGlzLmZpcnN0VW5yZWFkTWVzc2FnZUlkICYmXG4gICAgICAgICAgdGhpcy5sYXN0UmVhZE1lc3NhZ2VJZFxuICAgICAgICApIHtcbiAgICAgICAgICBjb25zdCBsYXN0UmVhZEluZGV4ID0gbWVzc2FnZXMuZmluZEluZGV4KFxuICAgICAgICAgICAgKG0pID0+IG0uaWQgPT09IHRoaXMubGFzdFJlYWRNZXNzYWdlSWRcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChsYXN0UmVhZEluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5maXJzdFVucmVhZE1lc3NhZ2VJZCA9IG1lc3NhZ2VzW2xhc3RSZWFkSW5kZXggKyAxXT8uaWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICAgIHRhcChcbiAgICAgICAgKG1lc3NhZ2VzKSA9PlxuICAgICAgICAgICh0aGlzLmxhc3RTZW50TWVzc2FnZUlkID0gWy4uLm1lc3NhZ2VzXVxuICAgICAgICAgICAgLnJldmVyc2UoKVxuICAgICAgICAgICAgLmZpbmQoXG4gICAgICAgICAgICAgIChtKSA9PlxuICAgICAgICAgICAgICAgIG0udXNlcj8uaWQgPT09IHRoaXMuY2hhdENsaWVudFNlcnZpY2UuY2hhdENsaWVudD8udXNlcj8uaWQgJiZcbiAgICAgICAgICAgICAgICBtLnN0YXR1cyAhPT0gJ3NlbmRpbmcnXG4gICAgICAgICAgICApPy5pZClcbiAgICAgICksXG4gICAgICB0YXAoKG1lc3NhZ2VzKSA9PiB7XG4gICAgICAgIGNvbnN0IGxhdGVzdE1lc3NhZ2VJbkxpc3QgPSBtZXNzYWdlc1ttZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgY29uc3QgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbFNlcnZpY2UuYWN0aXZlQ2hhbm5lbDtcbiAgICAgICAgY29uc3QgbWVzc2FnZXNGcm9tU3RhdGUgPVxuICAgICAgICAgICh0aGlzLm1vZGUgPT09ICdtYWluJ1xuICAgICAgICAgICAgPyBjaGFubmVsPy5zdGF0ZS5sYXRlc3RNZXNzYWdlc1xuICAgICAgICAgICAgOiBjaGFubmVsPy5zdGF0ZS50aHJlYWRzW3RoaXMucGFyZW50TWVzc2FnZT8uaWQgfHwgJyddKSB8fCBbXTtcbiAgICAgICAgdGhpcy5pc0xhdGVzdE1lc3NhZ2VJbkxpc3QgPVxuICAgICAgICAgICFsYXRlc3RNZXNzYWdlSW5MaXN0IHx8XG4gICAgICAgICAgbGF0ZXN0TWVzc2FnZUluTGlzdC5jaWQgIT09IGNoYW5uZWw/LmNpZCB8fFxuICAgICAgICAgICh0aGlzLm1vZGUgPT09ICd0aHJlYWQnICYmXG4gICAgICAgICAgICBsYXRlc3RNZXNzYWdlSW5MaXN0Py5wYXJlbnRfaWQgIT09IHRoaXMucGFyZW50TWVzc2FnZT8uaWQpIHx8XG4gICAgICAgICAgbGF0ZXN0TWVzc2FnZUluTGlzdD8uaWQgPT09XG4gICAgICAgICAgICBtZXNzYWdlc0Zyb21TdGF0ZVttZXNzYWdlc0Zyb21TdGF0ZS5sZW5ndGggLSAxXT8uaWQ7XG4gICAgICAgIGlmICghdGhpcy5pc0xhdGVzdE1lc3NhZ2VJbkxpc3QpIHtcbiAgICAgICAgICB0aGlzLmlzVXNlclNjcm9sbGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBtYXAoKG1lc3NhZ2VzKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpcmVjdGlvbiA9PT0gJ2JvdHRvbS10by10b3AnXG4gICAgICAgICAgPyBtZXNzYWdlc1xuICAgICAgICAgIDogWy4uLm1lc3NhZ2VzXS5yZXZlcnNlKCk7XG4gICAgICB9KSxcbiAgICAgIHRhcCgobWVzc2FnZXMpID0+IHtcbiAgICAgICAgdGhpcy5ncm91cFN0eWxlcyA9IG1lc3NhZ2VzLm1hcCgobSwgaSkgPT5cbiAgICAgICAgICBnZXRHcm91cFN0eWxlcyhtLCBtZXNzYWdlc1tpIC0gMV0sIG1lc3NhZ2VzW2kgKyAxXSwge1xuICAgICAgICAgICAgbGFzdFJlYWRNZXNzYWdlSWQ6IHRoaXMubGFzdFJlYWRNZXNzYWdlSWQsXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgdGhpcy5pc05leHRNZXNzYWdlT25TZXBhcmF0ZURhdGUgPSBtZXNzYWdlcy5tYXAoKG0sIGkpID0+XG4gICAgICAgICAgdGhpcy5jaGVja0lmT25TZXBhcmF0ZURhdGVzKG0sIG1lc3NhZ2VzW2kgKyAxXSlcbiAgICAgICAgKTtcbiAgICAgIH0pLFxuICAgICAgc2hhcmVSZXBsYXkoMSlcbiAgICApO1xuICAgIGlmICh0aGlzLnZpcnR1YWxpemVkTGlzdD8uanVtcFRvSXRlbSQpIHtcbiAgICAgIHRoaXMuanVtcFRvSXRlbVN1YnNjcmlwdGlvbiA9IHRoaXMudmlydHVhbGl6ZWRMaXN0Lmp1bXBUb0l0ZW0kXG4gICAgICAgIC5waXBlKGZpbHRlcigoanVtcFRvTWVzc2FnZSkgPT4gISFqdW1wVG9NZXNzYWdlLml0ZW0/LmlkKSlcbiAgICAgICAgLnN1YnNjcmliZSgoanVtcFRvTWVzc2FnZSkgPT4ge1xuICAgICAgICAgIGxldCBtZXNzYWdlSWQgPSBqdW1wVG9NZXNzYWdlLml0ZW0/LmlkO1xuICAgICAgICAgIGlmIChtZXNzYWdlSWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSnVtcGluZ1RvTGF0ZXN0VW5yZWFkTWVzc2FnZSkge1xuICAgICAgICAgICAgICBtZXNzYWdlSWQgPSB0aGlzLmZpcnN0VW5yZWFkTWVzc2FnZUlkIHx8IG1lc3NhZ2VJZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChqdW1wVG9NZXNzYWdlLnBvc2l0aW9uICE9PSAnYm90dG9tJykge1xuICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodGVkTWVzc2FnZUlkID0gbWVzc2FnZUlkO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRpcmVjdGlvbiA9PT0gJ3RvcC10by1ib3R0b20nKSB7XG4gICAgICAgICAgICAgIGp1bXBUb01lc3NhZ2UucG9zaXRpb24gPSAndG9wJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaXNKdW1waW5nVG9NZXNzYWdlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsTWVzc2FnZUludG9WaWV3KHtcbiAgICAgICAgICAgICAgbWVzc2FnZUlkOiB0aGlzLmZpcnN0VW5yZWFkTWVzc2FnZUlkIHx8IG1lc3NhZ2VJZCxcbiAgICAgICAgICAgICAgcG9zaXRpb246IGp1bXBUb01lc3NhZ2UucG9zaXRpb24gfHwgJ21pZGRsZScsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcmVzZXRTY3JvbGxTdGF0ZSgpIHtcbiAgICB0aGlzLmlzRW1wdHkgPSB0cnVlO1xuICAgIHRoaXMuaXNVc2VyU2Nyb2xsZWQgPSBmYWxzZTtcbiAgICB0aGlzLm1lc3NhZ2VJZFRvQW5jaG9yVG8gPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5hbmNob3JNZXNzYWdlVG9wT2Zmc2V0ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMubmV3TWVzc2FnZUNvdW50V2hpbGVCZWluZ1Njcm9sbGVkID0gMDtcbiAgICB0aGlzLmlzTmV3TWVzc2FnZVNlbnRCeVVzZXIgPSBmYWxzZTtcbiAgICB0aGlzLmlzTGF0ZXN0TWVzc2FnZUluTGlzdCA9IHRydWU7XG4gICAgdGhpcy5pc0p1bXBpbmdUb01lc3NhZ2UgPSBmYWxzZTtcbiAgICB0aGlzLnNjcm9sbFBvc2l0aW9uJC5uZXh0KCdib3R0b20nKTtcbiAgICB0aGlzLmxvYWRpbmdTdGF0ZSA9ICdpZGxlJztcbiAgfVxuXG4gIHByaXZhdGUgZGlzcG9zZVZpcnR1YWxpemVkTGlzdCgpIHtcbiAgICB0aGlzLnZpcnR1YWxpemVkTGlzdD8uZGlzcG9zZSgpO1xuICAgIHRoaXMuanVtcFRvSXRlbVN1YnNjcmlwdGlvbj8udW5zdWJzY3JpYmUoKTtcbiAgICB0aGlzLnF1ZXJ5U3RhdGVTdWJzY3JpcHRpb24/LnVuc3Vic2NyaWJlKCk7XG4gIH1cblxuICBwcml2YXRlIGdldCB1c2Vyc1R5cGluZyQoKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kZSA9PT0gJ3RocmVhZCdcbiAgICAgID8gdGhpcy51c2Vyc1R5cGluZ0luVGhyZWFkJFxuICAgICAgOiB0aGlzLnVzZXJzVHlwaW5nSW5DaGFubmVsJDtcbiAgfVxuXG4gIHByaXZhdGUgc2Nyb2xsTWVzc2FnZUludG9WaWV3KFxuICAgIG9wdGlvbnM6IHsgbWVzc2FnZUlkOiBzdHJpbmc7IHBvc2l0aW9uOiAndG9wJyB8ICdib3R0b20nIHwgJ21pZGRsZScgfSxcbiAgICB3aXRoUmV0cnk6IGJvb2xlYW4gPSB0cnVlXG4gICkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvcHRpb25zLm1lc3NhZ2VJZCk7XG4gICAgdGhpcy5qdW1wVG9NZXNzYWdlVGltZW91dHMuZm9yRWFjaCgodCkgPT4gY2xlYXJUaW1lb3V0KHQpKTtcbiAgICB0aGlzLmp1bXBUb01lc3NhZ2VUaW1lb3V0cyA9IFtdO1xuICAgIGlmICghZWxlbWVudCAmJiB3aXRoUmV0cnkpIHtcbiAgICAgIC8vIElmIHRoZSBtZXNzYWdlIHdhcyBuZXdseSBpbnNlcnRlZCBpbnRvIGFjdGl2ZUNoYW5uZWxNZXNzYWdlcyQsIHRoZSBtZXNzYWdlIHdpbGwgYmUgcmVuZGVyZWQgYWZ0ZXIgdGhlIGN1cnJlbnQgY2hhbmdlIGRldGVjdGlvbiBjeWNsZSAtPiB3YWl0IGZvciB0aGlzIGN5Y2xlIHRvIGNvbXBsZXRlXG4gICAgICB0aGlzLmp1bXBUb01lc3NhZ2VUaW1lb3V0cy5wdXNoKFxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2Nyb2xsTWVzc2FnZUludG9WaWV3KG9wdGlvbnMsIGZhbHNlKSlcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChlbGVtZW50KSB7XG4gICAgICBjb25zdCBibG9ja01hcHBpbmc6IHsgW2tleTogc3RyaW5nXTogU2Nyb2xsTG9naWNhbFBvc2l0aW9uIH0gPSB7XG4gICAgICAgIHRvcDogJ3N0YXJ0JyxcbiAgICAgICAgYm90dG9tOiAnZW5kJyxcbiAgICAgICAgbWlkZGxlOiAnY2VudGVyJyxcbiAgICAgIH07XG4gICAgICAvLyBXZSBjYW4ndCBrbm93IHdoZW4gc21vb3RoIHNjcm9sbGluZyBlbmRzLCBzbyB3ZSBzZXQgdGhlIGJlaGF2aW9yIHRvIGluc3RhbnQgaHR0cHM6Ly9naXRodWIuY29tL3czYy9jc3N3Zy1kcmFmdHMvaXNzdWVzLzM3NDRcbiAgICAgIGVsZW1lbnQuc2Nyb2xsSW50b1ZpZXcoe1xuICAgICAgICBiZWhhdmlvcjogJ2luc3RhbnQnIGFzIFNjcm9sbEJlaGF2aW9yLFxuICAgICAgICBibG9jazogYmxvY2tNYXBwaW5nW29wdGlvbnMucG9zaXRpb25dLFxuICAgICAgfSk7XG4gICAgICBpZiAob3B0aW9ucy5wb3NpdGlvbiAhPT0gJ21pZGRsZScpIHtcbiAgICAgICAgb3B0aW9ucy5wb3NpdGlvbiA9PT0gJ2JvdHRvbSdcbiAgICAgICAgICA/IHRoaXMuc2Nyb2xsVG9Cb3R0b20oKVxuICAgICAgICAgIDogdGhpcy5zY3JvbGxUb1RvcCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5qdW1wVG9NZXNzYWdlVGltZW91dHMucHVzaChcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5pc0p1bXBpbmdUb01lc3NhZ2UgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoIXRoaXMuaXNVc2VyU2Nyb2xsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tJZlVzZXJTY3JvbGxlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMjAwKVxuICAgICAgKTtcbiAgICAgIHRoaXMuanVtcFRvTWVzc2FnZVRpbWVvdXRzLnB1c2goXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWRNZXNzYWdlSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgdGhpcy5maXJzdFVucmVhZE1lc3NhZ2VJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB0aGlzLmlzSnVtcGluZ1RvTGF0ZXN0VW5yZWFkTWVzc2FnZSA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuanVtcFRvTWVzc2FnZVRpbWVvdXRzID0gW107XG4gICAgICAgICAgdGhpcy5jZFJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH0sIDEwMDApXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlzSnVtcGluZ1RvTWVzc2FnZSA9IGZhbHNlO1xuICAgICAgdGhpcy5oaWdobGlnaHRlZE1lc3NhZ2VJZCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZmlyc3RVbnJlYWRNZXNzYWdlSWQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmlzSnVtcGluZ1RvTGF0ZXN0VW5yZWFkTWVzc2FnZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgbmV3TWVzc2FnZVJlY2VpdmVkKG1lc3NhZ2U6IE1lc3NhZ2VSZXNwb25zZSkge1xuICAgIGlmIChcbiAgICAgICh0aGlzLm1vZGUgPT09ICdtYWluJyAmJiBtZXNzYWdlLnBhcmVudF9pZCkgfHxcbiAgICAgICh0aGlzLm1vZGUgPT09ICd0aHJlYWQnICYmIG1lc3NhZ2UucGFyZW50X2lkICE9PSB0aGlzLnBhcmVudE1lc3NhZ2U/LmlkKVxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpc05ld01lc3NhZ2VTZW50QnlDdXJyZW50VXNlciA9XG4gICAgICBtZXNzYWdlLnVzZXI/LmlkID09PSB0aGlzLmNoYXRDbGllbnRTZXJ2aWNlLmNoYXRDbGllbnQ/LnVzZXI/LmlkO1xuXG4gICAgbGV0IHNob3VsZERldGVjdENoYW5nZXMgPSBmYWxzZTtcblxuICAgIGlmICghdGhpcy5pc05ld01lc3NhZ2VTZW50QnlVc2VyICYmIGlzTmV3TWVzc2FnZVNlbnRCeUN1cnJlbnRVc2VyKSB7XG4gICAgICB0aGlzLmlzTmV3TWVzc2FnZVNlbnRCeVVzZXIgPSB0cnVlO1xuICAgICAgc2hvdWxkRGV0ZWN0Q2hhbmdlcyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNVc2VyU2Nyb2xsZWQpIHtcbiAgICAgIHRoaXMubmV3TWVzc2FnZUNvdW50V2hpbGVCZWluZ1Njcm9sbGVkKys7XG4gICAgICBzaG91bGREZXRlY3RDaGFuZ2VzID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzTmV3TWVzc2FnZVNlbnRCeVVzZXIgJiYgdGhpcy51bnJlYWRDb3VudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnVucmVhZENvdW50Kys7XG4gICAgICBzaG91bGREZXRlY3RDaGFuZ2VzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkRGV0ZWN0Q2hhbmdlcyAmJiB0aGlzLmlzVmlld0luaXRlZCkge1xuICAgICAgdGhpcy5jZFJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBjaGVja0lmT25TZXBhcmF0ZURhdGVzKFxuICAgIG1lc3NhZ2U/OiBTdHJlYW1NZXNzYWdlLFxuICAgIG5leHRNZXNzYWdlPzogU3RyZWFtTWVzc2FnZVxuICApIHtcbiAgICBpZiAoIW1lc3NhZ2UgfHwgIW5leHRNZXNzYWdlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBpc09uU2VwYXJhdGVEYXRlKG1lc3NhZ2UuY3JlYXRlZF9hdCwgbmV4dE1lc3NhZ2UuY3JlYXRlZF9hdCk7XG4gIH1cbn1cbiIsIjxuZy1jb250YWluZXJcbiAgKm5nSWY9XCJcbiAgICBsYXN0UmVhZE1lc3NhZ2VJZCAmJlxuICAgIGlzVW5yZWFkTm90aWZpY2F0aW9uVmlzaWJsZSAmJlxuICAgIG9wZW5NZXNzYWdlTGlzdEF0ID09PSAnbGFzdC1tZXNzYWdlJyAmJlxuICAgIGRpc3BsYXlVbnJlYWRTZXBhcmF0b3JcbiAgXCJcbj5cbiAgPG5nLWNvbnRhaW5lclxuICAgICpuZ1RlbXBsYXRlT3V0bGV0PVwiXG4gICAgICBjdXN0b21uZXdNZXNzYWdlc05vdGlmaWNhdGlvblRlbXBsYXRlIHx8XG4gICAgICAgIGRlZmF1bHRVbnJlYWRNZXNzYWdlc05vdGlmaWNhdGlvbjtcbiAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgdW5yZWFkQ291bnQ6IHVucmVhZENvdW50LFxuICAgICAgICBvbkRpc21pc3M6IG1lc3NhZ2VOb3RpZmljYXRpb25EaXNtaXNzQ2xpY2tlZCxcbiAgICAgICAgb25KdW1wOiBtZXNzYWdlTm90aWZpY2F0aW9uSnVtcENsaWNrZWRcbiAgICAgIH1cbiAgICBcIlxuICA+PC9uZy1jb250YWluZXI+XG48L25nLWNvbnRhaW5lcj5cbjxuZy10ZW1wbGF0ZVxuICAjZGVmYXVsdFVucmVhZE1lc3NhZ2VzTm90aWZpY2F0aW9uXG4gIGxldC11bnJlYWRDb3VudD1cInVucmVhZENvdW50XCJcbiAgbGV0LW9uRGlzbWlzcz1cIm9uRGlzbWlzc1wiXG4gIGxldC1vbkp1bXA9XCJvbkp1bXBcIlxuPlxuICA8ZGl2XG4gICAgY2xhc3M9XCJzdHItY2hhdF9fdW5yZWFkLW1lc3NhZ2VzLW5vdGlmaWNhdGlvblwiXG4gICAgZGF0YS10ZXN0aWQ9XCJ1bnJlYWQtbWVzc2FnZXMtbm90aWZpY2F0aW9uXCJcbiAgPlxuICAgIDxidXR0b25cbiAgICAgIGRhdGEtdGVzdGlkPVwidW5yZWFkLW1lc3NhZ2VzLW5vdGlmaWNhdGlvbi1qdW1wLXRvLW1lc3NhZ2VcIlxuICAgICAgKGNsaWNrKT1cIm9uSnVtcCgpXCJcbiAgICA+XG4gICAgICA8bmctY29udGFpbmVyXG4gICAgICAgICpuZ0lmPVwiXG4gICAgICAgICAgdW5yZWFkQ291bnQgPiAwICYmICFoaWRlVW5yZWFkQ291bnRGb3JOb3RpZmljYXRpb25BbmRJbmRpY2F0b3I7XG4gICAgICAgICAgZWxzZSBub1VucmVhZENvdW50XG4gICAgICAgIFwiXG4gICAgICA+XG4gICAgICAgIHt7XG4gICAgICAgICAgKHVucmVhZENvdW50ID09PSAxXG4gICAgICAgICAgICA/IFwic3RyZWFtQ2hhdC5cXHtcXHtjb3VudFxcfVxcfSB1bnJlYWQgbWVzc2FnZVwiXG4gICAgICAgICAgICA6IFwic3RyZWFtQ2hhdC5cXHtcXHtjb3VudFxcfVxcfSB1bnJlYWQgbWVzc2FnZXNcIlxuICAgICAgICAgICkgfCB0cmFuc2xhdGUgOiB7IGNvdW50OiB1bnJlYWRDb3VudCB9XG4gICAgICAgIH19XG4gICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgIDxuZy10ZW1wbGF0ZSAjbm9VbnJlYWRDb3VudD5cbiAgICAgICAge3sgXCJzdHJlYW1DaGF0LlVucmVhZCBtZXNzYWdlc1wiIHwgdHJhbnNsYXRlIH19XG4gICAgICA8L25nLXRlbXBsYXRlPlxuICAgIDwvYnV0dG9uPlxuICAgIDxidXR0b25cbiAgICAgIGRhdGEtdGVzdGlkPVwidW5yZWFkLW1lc3NhZ2VzLW5vdGlmaWNhdGlvbi1kaXNtaXNzXCJcbiAgICAgIChjbGljayk9XCJvbkRpc21pc3MoKVwiXG4gICAgPlxuICAgICAgPHN0cmVhbS1pY29uLXBsYWNlaG9sZGVyIGljb249XCJjbG9zZVwiPjwvc3RyZWFtLWljb24tcGxhY2Vob2xkZXI+XG4gICAgPC9idXR0b24+XG4gIDwvZGl2PlxuPC9uZy10ZW1wbGF0ZT5cbjxkaXYgI3Njcm9sbENvbnRhaW5lciBkYXRhLXRlc3RpZD1cInNjcm9sbC1jb250YWluZXJcIiBjbGFzcz1cInN0ci1jaGF0X19saXN0XCI+XG4gIDxuZy1jb250YWluZXIgKm5nSWY9XCJtb2RlID09PSAnbWFpbicgJiYgaXNFbXB0eSAmJiBlbXB0eUxpc3RUZW1wbGF0ZVwiPlxuICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJlbXB0eUxpc3RUZW1wbGF0ZVwiPjwvbmctY29udGFpbmVyPlxuICA8L25nLWNvbnRhaW5lcj5cbiAgPGRpdiBjbGFzcz1cInN0ci1jaGF0X19yZXZlcnNlLWluZmluaXRlLXNjcm9sbCBzdHItY2hhdF9fbWVzc2FnZS1saXN0LXNjcm9sbFwiPlxuICAgIDx1bCBjbGFzcz1cInN0ci1jaGF0X191bFwiPlxuICAgICAgPGxpXG4gICAgICAgICpuZ0lmPVwibW9kZSA9PT0gJ3RocmVhZCcgJiYgcGFyZW50TWVzc2FnZVwiXG4gICAgICAgICNwYXJlbnRNZXNzYWdlRWxlbWVudFxuICAgICAgICBkYXRhLXRlc3RpZD1cInBhcmVudC1tZXNzYWdlXCJcbiAgICAgICAgY2xhc3M9XCJzdHItY2hhdF9fcGFyZW50LW1lc3NhZ2UtbGlcIlxuICAgICAgPlxuICAgICAgICA8bmctY29udGFpbmVyXG4gICAgICAgICAgKm5nVGVtcGxhdGVPdXRsZXQ9XCJcbiAgICAgICAgICAgIG1lc3NhZ2VUZW1wbGF0ZUNvbnRhaW5lcjtcbiAgICAgICAgICAgIGNvbnRleHQ6IHsgbWVzc2FnZTogcGFyZW50TWVzc2FnZSwgaW5kZXg6ICdwYXJlbnQnIH1cbiAgICAgICAgICBcIlxuICAgICAgICA+PC9uZy1jb250YWluZXI+XG4gICAgICAgIDxkaXYgZGF0YS10ZXN0aWQ9XCJyZXBseS1jb3VudFwiIGNsYXNzPVwic3RyLWNoYXRfX3RocmVhZC1zdGFydFwiPlxuICAgICAgICAgIHt7cGFyZW50TWVzc2FnZS5yZXBseV9jb3VudCA9PT0gMSA/ICgnc3RyZWFtQ2hhdC4xIHJlcGx5JyB8IHRyYW5zbGF0ZSkgOiAoJ3N0cmVhbUNoYXQue3sgcmVwbHlDb3VudCB9fVxuICAgICAgICAgIHJlcGxpZXMnIHwgdHJhbnNsYXRlOnJlcGx5Q291bnRQYXJhbSl9fVxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvbGk+XG4gICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwibW9kZSA9PT0gJ3RocmVhZCcgJiYgaXNFbXB0eSAmJiBlbXB0eUxpc3RUZW1wbGF0ZVwiPlxuICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiZW1wdHlMaXN0VGVtcGxhdGVcIj48L25nLWNvbnRhaW5lcj5cbiAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgPHN0cmVhbS1sb2FkaW5nLWluZGljYXRvci1wbGFjZWhvbGRlclxuICAgICAgICAqbmdJZj1cIlxuICAgICAgICAgICgobG9hZGluZ1N0YXRlID09PSAnbG9hZGluZy10b3AnICYmIGRpcmVjdGlvbiA9PT0gJ2JvdHRvbS10by10b3AnKSB8fFxuICAgICAgICAgICAgKGxvYWRpbmdTdGF0ZSA9PT0gJ2xvYWRpbmctYm90dG9tJyAmJlxuICAgICAgICAgICAgICBkaXJlY3Rpb24gPT09ICd0b3AtdG8tYm90dG9tJykpICYmXG4gICAgICAgICAgICBkaXNwbGF5TG9hZGluZ0luZGljYXRvcjtcbiAgICAgICAgICBlbHNlIGxvYWRpbmdJbmRpY2F0b3JQbGFjZWhvbGRlclxuICAgICAgICBcIlxuICAgICAgICBkYXRhLXRlc3RpZD1cInRvcC1sb2FkaW5nLWluZGljYXRvclwiXG4gICAgICA+PC9zdHJlYW0tbG9hZGluZy1pbmRpY2F0b3ItcGxhY2Vob2xkZXI+XG4gICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwibWVzc2FnZXMkIHwgYXN5bmMgYXMgbWVzc2FnZXNcIj5cbiAgICAgICAgPG5nLWNvbnRhaW5lclxuICAgICAgICAgICpuZ0Zvcj1cIlxuICAgICAgICAgICAgbGV0IG1lc3NhZ2Ugb2YgbWVzc2FnZXM7XG4gICAgICAgICAgICBsZXQgaSA9IGluZGV4O1xuICAgICAgICAgICAgbGV0IGlzRmlyc3QgPSBmaXJzdDtcbiAgICAgICAgICAgIGxldCBpc0xhc3QgPSBsYXN0O1xuICAgICAgICAgICAgdHJhY2tCeTogdHJhY2tCeU1lc3NhZ2VJZFxuICAgICAgICAgIFwiXG4gICAgICAgID5cbiAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiaXNGaXJzdFwiPlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lclxuICAgICAgICAgICAgICAqbmdUZW1wbGF0ZU91dGxldD1cIlxuICAgICAgICAgICAgICAgIGRhdGVTZXBhcmF0b3I7XG4gICAgICAgICAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgICAgICAgICAgZGF0ZTogbWVzc2FnZS5jcmVhdGVkX2F0LFxuICAgICAgICAgICAgICAgICAgcGFyc2VkRGF0ZTogcGFyc2VEYXRlKG1lc3NhZ2UuY3JlYXRlZF9hdClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFwiXG4gICAgICAgICAgICA+PC9uZy1jb250YWluZXI+XG4gICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgPGxpXG4gICAgICAgICAgICB0YWJpbmRleD1cIjBcIlxuICAgICAgICAgICAgZGF0YS10ZXN0Y2xhc3M9XCJtZXNzYWdlXCJcbiAgICAgICAgICAgIGNsYXNzPVwic3RyLWNoYXRfX2xpIHN0ci1jaGF0X19saS0te3sgZ3JvdXBTdHlsZXNbaV0gfX1cIlxuICAgICAgICAgICAgaWQ9XCJ7eyBtZXNzYWdlLmlkIH19XCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyXG4gICAgICAgICAgICAgICpuZ1RlbXBsYXRlT3V0bGV0PVwiXG4gICAgICAgICAgICAgICAgbWVzc2FnZVRlbXBsYXRlQ29udGFpbmVyO1xuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHsgbWVzc2FnZTogbWVzc2FnZSwgaW5kZXg6IGkgfVxuICAgICAgICAgICAgICBcIlxuICAgICAgICAgICAgPjwvbmctY29udGFpbmVyPlxuICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgPG5nLWNvbnRhaW5lclxuICAgICAgICAgICAgKm5nSWY9XCJcbiAgICAgICAgICAgICAgKGxhc3RSZWFkTWVzc2FnZUlkID09PSBtZXNzYWdlPy5pZCAmJlxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbiA9PT0gJ2JvdHRvbS10by10b3AnKSB8fFxuICAgICAgICAgICAgICAoZGlyZWN0aW9uID09PSAndG9wLXRvLWJvdHRvbScgJiZcbiAgICAgICAgICAgICAgICBsYXN0UmVhZE1lc3NhZ2VJZCA9PT0gbWVzc2FnZXNbaSArIDFdPy5pZClcbiAgICAgICAgICAgIFwiXG4gICAgICAgICAgPlxuICAgICAgICAgICAgPGxpXG4gICAgICAgICAgICAgICpuZ0lmPVwiZGlzcGxheVVucmVhZFNlcGFyYXRvclwiXG4gICAgICAgICAgICAgIGlkPVwic3RyZWFtLWNoYXQtbmV3LW1lc3NhZ2UtaW5kaWNhdG9yXCJcbiAgICAgICAgICAgICAgZGF0YS10ZXN0aWQ9XCJuZXctbWVzc2FnZXMtaW5kaWNhdG9yXCJcbiAgICAgICAgICAgICAgY2xhc3M9XCJzdHItY2hhdF9fbGkgc3RyLWNoYXRfX3VucmVhZC1tZXNzYWdlcy1zZXBhcmF0b3Itd3JhcHBlclwiXG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIDxuZy1jb250YWluZXJcbiAgICAgICAgICAgICAgICAqbmdUZW1wbGF0ZU91dGxldD1cIlxuICAgICAgICAgICAgICAgICAgY3VzdG9tbmV3TWVzc2FnZXNJbmRpY2F0b3JUZW1wbGF0ZSB8fFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TmV3TWVzc2FnZXNJbmRpY2F0b3I7XG4gICAgICAgICAgICAgICAgICBjb250ZXh0OiB7IHVucmVhZENvdW50OiB1bnJlYWRDb3VudCB9XG4gICAgICAgICAgICAgICAgXCJcbiAgICAgICAgICAgICAgPjwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiaXNOZXh0TWVzc2FnZU9uU2VwYXJhdGVEYXRlW2ldXCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyXG4gICAgICAgICAgICAgICpuZ1RlbXBsYXRlT3V0bGV0PVwiXG4gICAgICAgICAgICAgICAgZGF0ZVNlcGFyYXRvcjtcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgICBkYXRlOiBtZXNzYWdlc1tpICsgMV0uY3JlYXRlZF9hdCxcbiAgICAgICAgICAgICAgICAgIHBhcnNlZERhdGU6IHBhcnNlRGF0ZShtZXNzYWdlc1tpICsgMV0uY3JlYXRlZF9hdClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFwiXG4gICAgICAgICAgICA+PC9uZy1jb250YWluZXI+XG4gICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICA8c3RyZWFtLWxvYWRpbmctaW5kaWNhdG9yLXBsYWNlaG9sZGVyXG4gICAgICAgICpuZ0lmPVwiXG4gICAgICAgICAgKChsb2FkaW5nU3RhdGUgPT09ICdsb2FkaW5nLWJvdHRvbScgJiZcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9PT0gJ2JvdHRvbS10by10b3AnKSB8fFxuICAgICAgICAgICAgKGxvYWRpbmdTdGF0ZSA9PT0gJ2xvYWRpbmctdG9wJyAmJlxuICAgICAgICAgICAgICBkaXJlY3Rpb24gPT09ICd0b3AtdG8tYm90dG9tJykpICYmXG4gICAgICAgICAgICBkaXNwbGF5TG9hZGluZ0luZGljYXRvcjtcbiAgICAgICAgICBlbHNlIGxvYWRpbmdJbmRpY2F0b3JQbGFjZWhvbGRlclxuICAgICAgICBcIlxuICAgICAgICBkYXRhLXRlc3RpZD1cImJvdHRvbS1sb2FkaW5nLWluZGljYXRvclwiXG4gICAgICA+PC9zdHJlYW0tbG9hZGluZy1pbmRpY2F0b3ItcGxhY2Vob2xkZXI+XG4gICAgICA8bmctdGVtcGxhdGUgI2xvYWRpbmdJbmRpY2F0b3JQbGFjZWhvbGRlcj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInN0ci1jaGF0X19sb2FkaW5nLWluZGljYXRvci1wbGFjZWhvbGRlclwiPjwvZGl2PlxuICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICA8L3VsPlxuICAgIDxuZy10ZW1wbGF0ZSAjZGVmYXVsdFR5cGluZ0luZGljYXRvciBsZXQtdXNlcnNUeXBpbmckPVwidXNlcnNUeXBpbmckXCI+XG4gICAgICA8IS0tIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAYW5ndWxhci1lc2xpbnQvdGVtcGxhdGUvbm8tYW55IC0tPlxuICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cIiRhbnkodXNlcnNUeXBpbmckIHwgYXN5bmMpIGFzIHVzZXJzXCI+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICAqbmdJZj1cInVzZXJzLmxlbmd0aCA+IDBcIlxuICAgICAgICAgIGRhdGEtdGVzdGlkPVwidHlwaW5nLWluZGljYXRvclwiXG4gICAgICAgICAgY2xhc3M9XCJzdHItY2hhdF9fdHlwaW5nLWluZGljYXRvciBzdHItY2hhdF9fdHlwaW5nLWluZGljYXRvci0tdHlwaW5nXCJcbiAgICAgICAgPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJzdHItY2hhdF9fdHlwaW5nLWluZGljYXRvcl9fZG90c1wiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJzdHItY2hhdF9fdHlwaW5nLWluZGljYXRvcl9fZG90XCI+PC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJzdHItY2hhdF9fdHlwaW5nLWluZGljYXRvcl9fZG90XCI+PC9zcGFuPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJzdHItY2hhdF9fdHlwaW5nLWluZGljYXRvcl9fZG90XCI+PC9zcGFuPlxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgIGRhdGEtdGVzdGlkPVwidHlwaW5nLXVzZXJzXCJcbiAgICAgICAgICAgIGNsYXNzPVwic3RyLWNoYXRfX3R5cGluZy1pbmRpY2F0b3JfX3VzZXJzXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICB7e1xuICAgICAgICAgICAgICB1c2Vycy5sZW5ndGggPT09IDFcbiAgICAgICAgICAgICAgICA/IChcInN0cmVhbUNoYXQudXNlciBpcyB0eXBpbmdcIlxuICAgICAgICAgICAgICAgICAgfCB0cmFuc2xhdGUgOiB7IHVzZXI6IGdldFR5cGluZ0luZGljYXRvclRleHQodXNlcnMpIH0pXG4gICAgICAgICAgICAgICAgOiAoXCJzdHJlYW1DaGF0LnVzZXJzIGFyZSB0eXBpbmdcIlxuICAgICAgICAgICAgICAgICAgfCB0cmFuc2xhdGUgOiB7IHVzZXJzOiBnZXRUeXBpbmdJbmRpY2F0b3JUZXh0KHVzZXJzKSB9KVxuICAgICAgICAgICAgfX1cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8L25nLXRlbXBsYXRlPlxuICAgIDxuZy1jb250YWluZXJcbiAgICAgICpuZ1RlbXBsYXRlT3V0bGV0PVwiXG4gICAgICAgIHR5cGluZ0luZGljYXRvclRlbXBsYXRlIHx8IGRlZmF1bHRUeXBpbmdJbmRpY2F0b3I7XG4gICAgICAgIGNvbnRleHQ6IGdldFR5cGluZ0luZGljYXRvckNvbnRleHQoKVxuICAgICAgXCJcbiAgICA+PC9uZy1jb250YWluZXI+XG4gIDwvZGl2PlxuPC9kaXY+XG48ZGl2IGNsYXNzPVwic3RyLWNoYXRfX2p1bXAtdG8tbGF0ZXN0LW1lc3NhZ2VcIj5cbiAgPGJ1dHRvblxuICAgICpuZ0lmPVwiaXNVc2VyU2Nyb2xsZWQgJiYgaXNKdW1wVG9MYXRlc3RCdXR0b25WaXNpYmxlXCJcbiAgICBkYXRhLXRlc3RpZD1cInNjcm9sbC10by1sYXRlc3RcIlxuICAgIGNsYXNzPVwic3RyLWNoYXRfX21lc3NhZ2Utbm90aWZpY2F0aW9uLXNjcm9sbC10by1sYXRlc3Qgc3RyLWNoYXRfX21lc3NhZ2Utbm90aWZpY2F0aW9uLXNjcm9sbC10by1sYXRlc3QtcmlnaHQgc3RyLWNoYXRfX2NpcmNsZS1mYWJcIlxuICAgIChrZXl1cC5lbnRlcik9XCJqdW1wVG9MYXRlc3RNZXNzYWdlKClcIlxuICAgIChjbGljayk9XCJqdW1wVG9MYXRlc3RNZXNzYWdlKClcIlxuICA+XG4gICAgPHN0cmVhbS1pY29uXG4gICAgICBjbGFzcz1cInN0ci1jaGF0X19qdW1wLXRvLWxhdGVzdC1pY29uIHN0ci1jaGF0X19jaXJjbGUtZmFiLWljb25cIlxuICAgICAgW2ljb25dPVwiZGlyZWN0aW9uID09PSAnYm90dG9tLXRvLXRvcCcgPyAnYXJyb3ctZG93bicgOiAnYXJyb3ctdXAnXCJcbiAgICA+PC9zdHJlYW0taWNvbj5cbiAgICA8ZGl2XG4gICAgICAqbmdJZj1cIm5ld01lc3NhZ2VDb3VudFdoaWxlQmVpbmdTY3JvbGxlZCA+IDBcIlxuICAgICAgY2xhc3M9XCJzdHItY2hhdF9fbWVzc2FnZS1ub3RpZmljYXRpb24gc3RyLWNoYXRfX21lc3NhZ2Utbm90aWZpY2F0aW9uLXNjcm9sbC10by1sYXRlc3QtdW5yZWFkLWNvdW50IHN0ci1jaGF0X19qdW1wLXRvLWxhdGVzdC11bnJlYWQtY291bnRcIlxuICAgID5cbiAgICAgIHt7IG5ld01lc3NhZ2VDb3VudFdoaWxlQmVpbmdTY3JvbGxlZCB9fVxuICAgIDwvZGl2PlxuICA8L2J1dHRvbj5cbjwvZGl2PlxuXG48bmctdGVtcGxhdGUgI21lc3NhZ2VUZW1wbGF0ZUNvbnRhaW5lciBsZXQtbWVzc2FnZT1cIm1lc3NhZ2VcIiBsZXQtaW5kZXg9XCJpbmRleFwiPlxuICA8bmctdGVtcGxhdGVcbiAgICAjZGVmYXVsdE1lc3NhZ2VUZW1wbGF0ZVxuICAgIGxldC1tZXNzYWdlSW5wdXQ9XCJtZXNzYWdlXCJcbiAgICBsZXQtaXNMYXN0U2VudE1lc3NhZ2U9XCJpc0xhc3RTZW50TWVzc2FnZVwiXG4gICAgbGV0LWVuYWJsZWRNZXNzYWdlQWN0aW9ucz1cImVuYWJsZWRNZXNzYWdlQWN0aW9uc1wiXG4gICAgbGV0LW1vZGU9XCJtb2RlXCJcbiAgICBsZXQtaXNIaWdobGlnaHRlZD1cImlzSGlnaGxpZ2h0ZWRcIlxuICAgIGxldC1zY3JvbGwkPVwic2Nyb2xsJFwiXG4gID5cbiAgICA8c3RyZWFtLW1lc3NhZ2VcbiAgICAgIFttZXNzYWdlXT1cIm1lc3NhZ2VJbnB1dFwiXG4gICAgICBbaXNMYXN0U2VudE1lc3NhZ2VdPVwiaXNMYXN0U2VudE1lc3NhZ2VcIlxuICAgICAgW2VuYWJsZWRNZXNzYWdlQWN0aW9uc109XCJlbmFibGVkTWVzc2FnZUFjdGlvbnNcIlxuICAgICAgW21vZGVdPVwibW9kZVwiXG4gICAgICBbaXNIaWdobGlnaHRlZF09XCJpc0hpZ2hsaWdodGVkXCJcbiAgICAgIFtzY3JvbGwkXT1cInNjcm9sbCRcIlxuICAgID48L3N0cmVhbS1tZXNzYWdlPlxuICA8L25nLXRlbXBsYXRlPlxuICA8bmctY29udGFpbmVyXG4gICAgKm5nVGVtcGxhdGVPdXRsZXQ9XCJcbiAgICAgIG1lc3NhZ2VUZW1wbGF0ZSB8fCBkZWZhdWx0TWVzc2FnZVRlbXBsYXRlO1xuICAgICAgY29udGV4dDoge1xuICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICBpc0xhc3RTZW50TWVzc2FnZTogISEoXG4gICAgICAgICAgbGFzdFNlbnRNZXNzYWdlSWQgJiYgbWVzc2FnZT8uaWQgPT09IGxhc3RTZW50TWVzc2FnZUlkXG4gICAgICAgICksXG4gICAgICAgIGVuYWJsZWRNZXNzYWdlQWN0aW9uczogZW5hYmxlZE1lc3NhZ2VBY3Rpb25zLFxuICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgICBpc0hpZ2hsaWdodGVkOiBtZXNzYWdlPy5pZCA9PT0gaGlnaGxpZ2h0ZWRNZXNzYWdlSWQsXG4gICAgICAgIHNjcm9sbCQ6IHNjcm9sbCRcbiAgICAgIH1cbiAgICBcIlxuICA+PC9uZy1jb250YWluZXI+XG48L25nLXRlbXBsYXRlPlxuXG48bmctdGVtcGxhdGUgI2RhdGVTZXBhcmF0b3IgbGV0LWRhdGU9XCJkYXRlXCIgbGV0LXBhcnNlZERhdGU9XCJwYXJzZWREYXRlXCI+XG4gIDxuZy1jb250YWluZXIgKm5nSWY9XCJkaXNwbGF5RGF0ZVNlcGFyYXRvclwiPlxuICAgIDxuZy1jb250YWluZXJcbiAgICAgICpuZ1RlbXBsYXRlT3V0bGV0PVwiXG4gICAgICAgIGN1c3RvbURhdGVTZXBhcmF0b3JUZW1wbGF0ZSB8fCBkZWZhdWx0RGF0ZVNlcGFyYXRvcjtcbiAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgIGRhdGU6IGRhdGUsXG4gICAgICAgICAgcGFyc2VkRGF0ZTogcGFyc2VkRGF0ZVxuICAgICAgICB9XG4gICAgICBcIlxuICAgID48L25nLWNvbnRhaW5lcj5cbiAgPC9uZy1jb250YWluZXI+XG5cbiAgPG5nLXRlbXBsYXRlXG4gICAgI2RlZmF1bHREYXRlU2VwYXJhdG9yXG4gICAgbGV0LWRhdGU9XCJkYXRlXCJcbiAgICBsZXQtcGFyc2VkRGF0ZT1cInBhcnNlZERhdGVcIlxuICA+XG4gICAgPGRpdiBkYXRhLXRlc3RpZD1cImRhdGUtc2VwYXJhdG9yXCIgY2xhc3M9XCJzdHItY2hhdF9fZGF0ZS1zZXBhcmF0b3JcIj5cbiAgICAgIDxoclxuICAgICAgICAqbmdJZj1cIlxuICAgICAgICAgIGRhdGVTZXBhcmF0b3JUZXh0UG9zID09PSAncmlnaHQnIHx8IGRhdGVTZXBhcmF0b3JUZXh0UG9zID09PSAnY2VudGVyJ1xuICAgICAgICBcIlxuICAgICAgICBjbGFzcz1cInN0ci1jaGF0X19kYXRlLXNlcGFyYXRvci1saW5lXCJcbiAgICAgIC8+XG4gICAgICA8ZGl2IGNsYXNzPVwic3RyLWNoYXRfX2RhdGUtc2VwYXJhdG9yLWRhdGVcIj5cbiAgICAgICAge3sgcGFyc2VkRGF0ZSB9fVxuICAgICAgPC9kaXY+XG4gICAgICA8aHJcbiAgICAgICAgKm5nSWY9XCJcbiAgICAgICAgICBkYXRlU2VwYXJhdG9yVGV4dFBvcyA9PT0gJ2xlZnQnIHx8IGRhdGVTZXBhcmF0b3JUZXh0UG9zID09PSAnY2VudGVyJ1xuICAgICAgICBcIlxuICAgICAgICBjbGFzcz1cInN0ci1jaGF0X19kYXRlLXNlcGFyYXRvci1saW5lXCJcbiAgICAgIC8+XG4gICAgPC9kaXY+XG4gIDwvbmctdGVtcGxhdGU+XG48L25nLXRlbXBsYXRlPlxuXG48bmctdGVtcGxhdGUgI2RlZmF1bHROZXdNZXNzYWdlc0luZGljYXRvciBsZXQtdW5yZWFkQ291bnQ9XCJ1bnJlYWRDb3VudFwiPlxuICA8ZGl2IGNsYXNzPVwic3RyLWNoYXRfX3VucmVhZC1tZXNzYWdlcy1zZXBhcmF0b3JcIj5cbiAgICA8bmctY29udGFpbmVyXG4gICAgICAqbmdJZj1cIlxuICAgICAgICB1bnJlYWRDb3VudCA+IDAgJiYgIWhpZGVVbnJlYWRDb3VudEZvck5vdGlmaWNhdGlvbkFuZEluZGljYXRvcjtcbiAgICAgICAgZWxzZSBub1VucmVhZENvdW50XG4gICAgICBcIlxuICAgID5cbiAgICAgIHt7XG4gICAgICAgICh1bnJlYWRDb3VudCA9PT0gMVxuICAgICAgICAgID8gXCJzdHJlYW1DaGF0Llxce1xce2NvdW50XFx9XFx9IHVucmVhZCBtZXNzYWdlXCJcbiAgICAgICAgICA6IFwic3RyZWFtQ2hhdC5cXHtcXHtjb3VudFxcfVxcfSB1bnJlYWQgbWVzc2FnZXNcIlxuICAgICAgICApIHwgdHJhbnNsYXRlIDogeyBjb3VudDogdW5yZWFkQ291bnQgfVxuICAgICAgfX1cbiAgICA8L25nLWNvbnRhaW5lcj5cbiAgICA8bmctdGVtcGxhdGUgI25vVW5yZWFkQ291bnQ+XG4gICAgICB7eyBcInN0cmVhbUNoYXQuVW5yZWFkIG1lc3NhZ2VzXCIgfCB0cmFuc2xhdGUgfX1cbiAgICA8L25nLXRlbXBsYXRlPlxuICA8L2Rpdj5cbjwvbmctdGVtcGxhdGU+XG4iXX0=